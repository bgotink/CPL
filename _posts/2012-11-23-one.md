---
layout: post
title: Assignment 1
---

{{page.title}}
==============

__All characters in this work are fictitious. Any resemblance to real persons, living or dead, is purely coincidental [1]__

## Introduction

__Mister B.__  
Mister B. is an experienced C-programmer at C-Coders. All the programs that are developed in this company are written in C. And Mister B. loves that. In his student years, Mister B. also came into contact with Java. However, he already knew the language C and he only learned Java because he had to. In his opinion, C is the best language and there's no need to discuss that.  

__Denis L.__  
Denis has just graduated from the university and is eager to start with a new chapter in his life: going to work. Today is his first day at work and he's meeting with Mister B, the leader of his assigned team. At the university, Denis came in contact with just one programming language, namely Java. How he got passed the interviews without any knowledge of C remains a mystery. But that's that. Today is the day that Denis can ask everything about C to Mister B. 

## Conversation

__Hey mister B, this may be a stupid question, but how do I create an object in C?__  
Simple answer, you can't. C is not an object-oriented language but a procedural one.  There are, however, certain structures in this language which allow you to create object-like structures. They only contain data, no methods or other typical object-oriented members.  

__A procedural language, you say?__  
In a procedural programming, you typically break down a programming task into a collection of variables, data structures and subroutines. In object-oriented programming on the other hand, you break it down into objects that expose behaviour (methods) and data (variables) using interfaces. In an object-oriented language like Java, an instance of a class, operates on its own data structure. In C, all data is exposed[2].  

__You mentioned something about object-like structures?__  
Yeah, they're called structures and are defined using the keyword struct. Let me give an example.

```C
struct Address {
	char *streetName;
	int number, postalCode;
	char *city, *state, *country;
};
```

This piece of C code defines a structure containing strings and integers. You can easily create new variables of this structure type using

```C
struct Address homeAddress;
```

However, this requires writing `C struct Address` every time you want to declare a new variable of that type. You can also create the same structure using:

```C
typedef struct {
	char *streetName;
	int number, postalCode;
	char *city, *state, *country;
} Address;
```

Creating new Address variables is now simply

```C
Address homeAddress;
```

__What's with all the stars?__  
They are called pointers. Pointers are very common and are used almost everywhere because in C, you have direct access to the memory. A pointer is a variable that holds the location of the actual value in memory. They are like memory addresses but they aren't real memory addresses because most systems do memory translation.

When you declare a pointer, it initially points to `C NULL` (memory address `C 0`). You still have to make the pointer point to the actual data that you may still need to create. In order to do this, you can use the 'address-of' operator, '`c &`' or allocate memory on the heap. 

```C
int number, *pointer_to_number;
number = 42;
pointer_to_number = &number;
```

In this example, `C pointer_to_number` is of type 'pointer to int' and its value is the memory location of the integer `C number`. You can also access the value of `C number` through the pointer with the dereference operator, '`c *`'.

```C
*pointer_to_int = 3;
```

Here, the value of `C number` is changed to 3 using the pointer.

__How can I access the fields of structures?__  
The fields of a structure can be accessed using the 'dot' operator, much like in Java:

```C
struct Address homeAddress;
int homeNumber = homeAddress.number;
```

If you have a pointer pointing to a struct, you can also access the members with the 'pointing-to' operator, '`C ->`'.

```C
struct Address *address = &homeAddress;
int homeNumber = address->number;
```

As all data of a struct is public, the fields are accessed directly.

__You said Address contains strings but if I understand correctly, there are only pointers to characters?__  
There is no "String" type in C. In C, a string is an array of characters, terminated with a 'null' character, `C '\0'`. This means that a character array of length 7 can only contain a string with 6 characters as the null character takes up 1 place.

__Why is an array of characters terminated with `C '\0'` ?__  
As C never does automatic bounds checks, it means the end of an array is unknown. To know the end of the string, character arrays are terminated with `C '\0'`. This termination  allows easy use of strings, because the length of the string can be determined by checking for the `C '\0'` character. By the way, arrays that contain elements of a different type are not automatically null-terminated.

__As C does not perform automatic bounds checks, how does it prevent everybody from writing beyond the end of an array?__  
Well simply said, it doesn't. The compiler will for example allow you to compile this piece of code that writes beyond the range of the `C overflowArray` array.

```C
int overflowArray[10];
int fixedArray[10];
	int i;
	for(i=0; i<10; i++){
		fixedArray[i] = i;
	}
	for(i=0; i<18; i++){
		overflowArray[i] = i;
	}
	for(i=0; i<10; i++){
		printf("%d \n", fixedArray[i]);
	}
```

This piece of code prints:

```
12 
13 
14 
15 
16 
17 
6 
7 
8 
9 
```

I wrote integers in `C overflowArray` while I was actually writing in and beyond `C fixedArray`.  
This is a very basic example of a buffer overflow. A buffer overflow occurs when	 a program writes beyond the size of the buffer and thus overwrites memory that does not belong to the buffer anymore.  
The buffer overflow is one of the most common bugs in software. A lot of the iOS jailbreaks use this to acquire root privileges, enabling the program to alter the OS.

__Well, it seems to me that C is very basic compared to Java, no bounds checking on arrays... I like my `java java.lang.ArrayIndexOutOfBoundsException`!__  
__Is C that much older than java? How was C created? [3]__  
The programming language C was created by Dennis Ritchie between the years 1969 and 1973. At that time, Ritchie worked at AT&T Bell Labs (New Jersey, USA). This research and development company is also known for the invention of the UNIX operating system family.

The origin of C is by the way largely connected with this operating system family. UNIX was originally written in assembly language. When they decided to port the operating system to a PDP-11, a 16-bit minicomputer, they realised that their primary programming language at that time, namely B, couldn't take advantage of some important features of the PDP-11. This fact initiated the development of C.

Note that the language B is a stripped down and syntactically changed version of the programming language BCPL (Basic Compiled Programming Language). BCPL was used in an earlier operating system, namely MULTICS.

__So, did they just name this new programming language "C" because the previous language was named "B"?__  
No, absolutely not. Well, maybe. But the main reason they called this new language C is because it actually derives a lot of features of B. As said, they needed to extend B to optimise the use of the PDP-11. It was then a logical implication to name the new language "C".

__What are the additions of C in comparison with B then?__
The most important addition is probably the addition of structs. To recap, structs are the object-like structures I mentioned earlier. Thanks to the implementation of these structs, C became powerful enough so that UNIX kernel could be mainly written in it. Another important addition is the addition of the data types for variables.

In short, you can say that C inherits the concise syntax of B and added the necessary high-level functionality and detailed features that are needed to write a (modern) operating system. The invention of C resulted in the end of B.

__We are talking about 40 years ago. As you just said, the programming language B vanished because of the invention of C. Why didn't the same happen to C? Or, in other words, why are we still talking about C these days?__  
That's a really good question. Remember that the UNIX kernel was eventually written in C. When the UNIX operating system conquered the world, the knowledge of C became widespread and it eventually became the number one programming language. 

Nowadays, C is still the default language for UNIX and UNIX-like systems. So if you want to make a contribution, even a small one, you'll need to know C. 

__Since C code is necessary to write libraries for UNIX, I assume that the programming language is widely used?__  
Correct. In fact, according to TIOBE Programming Community Index for November 2012, C is the most popular language on Earth with a market share of largely 19.2%. And what is interesting, is that the top 6 of this ranking is fully taken by C-based languages. This is good for a market share of 68%! In other words, more than 2 out of 3 programs are written in a language that's derived from C. That is huge. And it's the reason why C is called the mother of all programming languages.

__Wow! A 40-year old language still rocking the programming world. That's impressive! Did the language just roll off the shelve?__  
No, of course not. There are different stages in the evolution of the language. The version of C that was used to implement the UNIX kernel is known as the "Early Developments". 

The first published version came in 1978 when Kernighan and Ritchie published their book "The C Programming Language". For years, many programmers referenced this book as the informal specification of the language. Nowadays, this book is still known to C-programmers as the K&R standard or the K&R C.

In 1983, the American National Standards Institute (ANSI) filed a request for a standard specification for the C language. This standardization was largely based on the UNIX implementation and was published in 1989. This standard of C is referred to by programmers as ANSI C or C89. 

This standard was unchanged for years. And to be more precise: for 10 years. In 1999, the standard was revised and several new features, like for example new data types (long, long int, complex) and variable length arrays, were introduced. But also the support for one-line comment to begin with // was introduced. This last feature was seen in the programming language BCPL. This standard is worldwide known as C99.

A last update, well at least until now, came in 2011 when the C11 standard was published. In this standard, the C standard is extended by new features like for example anonymous structures, atomic operations and multi-threading.

__Aah, interesting! Before, you said that C is the mother of all programming languages... Which languages are then derived from C?__  
The list is enormous. But the most known languages are probably C++, C#, Objective-C, PHP, JavaScript and... Java.

__Wait, what? Java?! I don't get it…__  
Yes, Java! The syntax of Java is largely based on C's. But don't get me wrong: there are many, many differences between C and Java. You already discovered the major difference, namely the fact that you can't create objects in C. 

Another important difference is that C code compiles directly to machine code. Java, on the other hand, uses a virtual machine, namely the Java Virtual Machine (JVM), and all the Java code will be compiled to Java bytecode. This code runs in the JVM. The only thing that is necessary for your machine to run Java code is an installed Java Runtime Environment, or JRE, which includes a JVM. These JRE's can be freely download on the web.

The advantage is that when you're Java code is compiled, you can run it on every machine that has a JVM installed. It does not matter if you compiled the code on a Mac and you want to run it on a Windows machine. This is not the case with C and its C compiler since the compiler will match C code to local machine instructions. These commands could (and do) differ between machines. Thus, compiled C code cannot run on a machine that has different machine instructions.

__Oh, I see. And what is the contribution of C to the other languages that derive from it? Is it also solely the syntax?__  
Hmm, that differs from language to language. As said, the only similarity between Java and C is the syntax. The same can be said about JavaScript and PHP. The syntax that we're talking about is the structured programming syntax, like the if-statements and for- and while-loops. Well, actually, all the languages that I mentioned before inherit this syntax. 

Languages like C++ and Objective-C are far more closely related to C than Java is. They were invented when object-oriented languages became more widely used and extend the C-language with object-oriented capabilities. 

__Wow, seems like we got a little sidetracked… Enough about C and its history. I thought you mentioned something about memory? How does that work in C?__  
A program can allocate memory in two regions: the stack or the heap. The stack has a fixed size, which is why you can can end up with a stack overflow error. The size of the heap is not fixed and can vary during execution. 
When you instantiate variables, they are automatically stored on the stack. When the function returns, they are freed. If you need a longer lifetime for a variable, you should allocate memory on the heap. This is done with the '`C malloc`' function, which returns a pointer to a chunk of memory of a given size.

```C
Address *addr_ptr = (Address *) malloc(sizeof(Address));
addr_ptr->postal = 3000;
```

Pointers are a powerful part of the C language. You can easily create very potent code, but you can also easily introduce bugs. One thing you mustn't forget is freeing the memory you've allocated for the object when you no longer need it. This can be done using the '`C free`' function.

```C
free(myAddr_ptr);
```

If you don't do this, the memory will remain allocated, and eventually your computer will run out of memory. This is what is called a memory leak.

Another important fact to remember, is that the memory for your object allocated by `C malloc` is not initialised. It still contains the data that was there before `C malloc` was called. Reading variables from a freshly created `C Address*` results in undefined behaviour. Executing `C printf("%s", myAddrPtr->streetName);` will probably print jibberish to `C stdout`, or even result in a memory-related error. 

__Is '(Address *)' a cast and why do you need to cast that pointer?__  
Yes, it is. In C, you can cast types to other types. The reason for the cast is the `C malloc` function. The declaration of `C malloc` reads

```C
void *malloc(size_t size)
```

In other words, it returns a pointer of type 'pointer to void'. In the previous example, you declare a pointer of type 'pointer to Address' and because of that, you technically need to cast it to that type. In fact, most compilers will do the casting automatically but doing the cast manually is generally considered good practice. For instance, C++ requires the cast and in older versions of C, `C malloc` returned `C char *`.

__So I can just cast a 'pointer to void' to anything I want?__
The short answer is yes. You can cast everything to something else. The compiler will give you a warning if you're casting a pointer to an integer type, and an error if you try to cast a struct variable to a primitive or vice versa.

```C
Type var, *ptr;
ptr = (Type *) var;
```

results in:

```console
Mr.B:/tmp$ gcc cast.c
cast.c: In function 'main':
cast.c:7:2: error: cannot convert to a pointer type
```

In the other direction,

```C
var = (Type) ptr;
```

results in:

```console
Mr.B:/tmp$ gcc cast.c
cast.c: In function 'main':
cast.c:7:2: error: conversion to non-scalar type requested
```

When using integers,

```C
int i = (int) var;
```

results in:

```Console
Mr.B:/tmp$ gcc cast.c
cast.c: In function 'main':
cast.c:8:2: error: aggregate value used where an integer was expected
```

__What's the difference between 'pointer to Address' and 'pointer to void' then?__  
Even though pointers have equal sizes, they don't point to values of equal sizes. For instance, a variable of type `C char` doesn't take as many memory as a variable of type `C int`. In C, pointers are also used to iterate over a collection of data. This is done by increasing the pointer with 'one' but that one needs to be the exact size of the structure it is pointing to. This is the reason why pointers have different types, they need to know the size of the type they are pointing to. 

```C
int *int_ptr;
char *char_ptr;
int_ptr++;  // equivalent to: int_ptr += sizeof(int);
char_ptr++; // equivalent to: char_ptr += sizeof(char);
```

__If pointers are so powerful, why doesn't Java have them?__  
Well, java has pointers. You just don't see them. Every instance of any subclass of `java java.lang.Object` in Java is actually a pointer to an object. Java takes care of all the memory management, and prevents any real pointer operations (like going to the next address).

<b>So, if I create a function

```C
int getPostal1(Address *addr) {
	return addr->postalCode;
}
```

the argument can be invalid?</b>  
Yes. The argument can be NULL, or simply a pointer to something else.


<b> Can't I create the function

```C
int getPostal2(Address addr) {
	return addr.postalCode;
}
```

?</b>  
Of course you can! However, there is no guarantee that the `c address` parameter is a valid `c Address`. The parameter cannot be `C NULL`, but C allows casting, so it can be everything. Another possibility would be to use `C getPostal3`.

```C
int getPostal3(Address *addr) {
	if (addr) {
		return addr->postalCode;
	} else {
		return 0;
	}
}
```

This returns `c 0` if `C NULL` is given as argument.

By the way, there is an important difference between `C getPostal2` and `C getPostal1`/`C getPostal3`! The latter receives a pointer to the real variable, the first receives a copy of the variable!
Let me explain. Suppose we have the following two functions:

```C
int setPostal_ptr(Address *addr_ptr, int postal) {
	addr_ptr->postalCode = postal;
}

int setPostal_dir(Address addr, int postal) {
	addr.postalCode = postal;
}
```

We now have the following code:

```C
Address one, two;
one.postal = two.postal = 3000; // Leuven

setPostal_dir(one, 3001); // Heverlee
setPostal_ptr(&two, 3001); // Heverlee as well

printf("%d\n", one.postalCode);
printf("%d\n", two.postalCode);
```

What output do you expect?  
__I expect to see 3001 twice, why?__  
Well, you're wrong. The output is

```
	3000
	3001
```

This is because the parameters of the function are always copied. So, if we call `C setPostal_dir(one, 3001);`
the function actually gets a copy of `c one` and a copy of `c 3001`. It then sets the `c postalCode` variable of the copy of `c one`, so `c one` itself is not changed!

However, when we use
`c setPostal_ptr(&two, 3001);`
the function gets a copy of the pointer to `c two` and a copy of `c 3001`. The copy of the pointer to `c two` obviously points to `c two` as well, so if we set the `c postalCode` like we do in the function, the actual `c postalCode` of `c two` is changed.

__But if I don't need to change the parameter, I can still use the `c getPostal2` function?__  
That is possible. However, you have to take in account that copying the variable requires time and memory. If you have a variable of type `c HugeStruct`, this could really have an effect on the speed of your program, as it needs to copy 1MB of data every time the variable has to be copied.

```C
typedef struct {
	int buff[1024 * 1024]; // a 1MB buffer
} HugeStruct;
```

__So Java actually gives pointers to the variables in methods?__  
Yes and no. In Java, you can change the parameter objects (e.g. `java setPostalCode` on an `java Address` object), but you cannot change which object the parameter references.

```java
public class Test {
	public static void doTest(Address addr) {
		Addres newAddr = new Address("Celestijnenlaan", 200, 3001, "Heverlee", "Belgium");
		addr = newAddr;
	}
}
```

After calling `java Test.doTest(address)`, `java address` is unchanged! By assigning a new object to `java address` in the code, the reference changed to a new object in the scope of the callee (`java Test.doTest`). In the scope of the caller however, this didn't happen.
In C, this is possible:

```C
void test(Address *addr) {
	Address newAddr;
	newAddr.postalCode = 3000;
	*addr = newAddr;
}
```

Calling `c test(address)` results in address being reset, and the `c postalCode` is set to `c 3000`. 

__I noticed you wrote if(addr) in the getPostal3 function above. Is that truly valid code? Shouldn't that be if(addr != NULL)?__  
I understand your confusion, but this code is really valid. In Java you should write `java if(addr != null)` to check whether `java addr` is `java null` or not. In C you can do this by simply writing `c if(addr)`. Thus it is possible to check no matter what type of object using `c if`, because the C language does not contain booleans. 

__No booleans? How do test-statements work then?__  
Well, C uses integers as default return value of comparison operators like <, > and ==.
An expression evaluates to `c FALSE` when the value is zero, otherwise the expression evaluates to `c TRUE`. 
Starting from C99, the type bool was introduced in the header file `c <stdbool.h>`, this is actually a boolean (1 bit, true or false).

__Header files, this seems to be another difference between Java and C, what are they used for?__  
Header files are actually a declaration of the public interfaces of the source files of libraries or self written code.


__And how do I use those in a source file then?__  
Actually this is very similar to imports in Java. In Java, you need to import classes from other packages with the `java import` keyword. For example, if you want to use a class `java Address` in the package `java example.package`, you write:

```java
import example.package.Address;
```

In C, you need to include the header file defining the functions and structs you need. Like so:

```C
#include "Address.h"
```

The difference between these two is that Java will just use this statement to look up the Address class and its interface. C does not have classes. By including `c Address.h`, all type definitions and data declarations become available to the program. 
One more thing to notice is that the include statement can be used in two ways. [4]

```C
#include <stdio.h>
#include "stdio.h"
```

Both are valid but there is a big difference. In the first line, the preprocessor will look for stdio.h in the system libraries first and if it cannot find it there, it will look for stdio.h in the current directory. Using the quotes will cause the preprocessor to only look in the current working directory, i.e. the directory where the file containing this line resides.   
You can specify additional folders containing system libraries with the `c -I` option of the compiler.

A notable difference between C's `c #include` and Java's `java import`, is that `c #include` actually includes the entire header file in the current file. This can lead to problems when two header files `c #include` each other.
Suppose we have two header files, `c a.h` and `c b.h`.  
a.h:

```c
#include "b.h"
// the rest of the header
```

b.h:

```c
#include "a.h"
// the rest of the header
```

If I now compile the empty program `c headers.c`:

```c
#include "a.h"
int main(void) {
	return 0;
}
```

the following error will show on the terminal:

```console
Mr.B:/tmp/headers$ gcc -o headers headers.c
In file included from a.h:1:0,
                 from b.h:1,
                 from a.h:1,
                 …
                 from b.h:1,
                 from a.h:1,
                 from b.h:1,
                 from a.h:1,
                 from headers.c:2:
a.h:1:15: error: #include nested too deeply
```

This can be fixed by using the preprocessor directives `c #define` and `c #ifdef`.

a.h:

```c
#pragma message "loading a.h"
#ifdef __A__
#define __A__
#pragma message "actually loading a.h"
#include "b.h"
// the rest of the header
#endif
```

b.h:

```c
#pragma message "loading b.h"
#ifndef __B__
#define __B__
#pragma message "actually loading b.h"
#include "a.h"
// the rest of the header
#endif
```

The compiler will now output:

```console
Mr.B:/tmp/headers$ gcc -o headers headers.c
In file included from headers.c:1:0:
a.h:1:9: note: #pragma message: loading a.h
a.h:5:9: note: #pragma message: actually loading a.h
In file included from a.h:7:0,
                 from headers.c:1:
b.h:1:9: note: #pragma message: loading b.h
b.h:5:9: note: #pragma message: actually loading b.h
In file included from b.h:6:0,
                 from a.h:7,
                 from headers.c:1:
a.h:1:9: note: #pragma message: loading a.h
```

As you can see, a.h includes b.h, which includes a.h, but the second time a.h is included, `C __A__` is already defined, so the body of the `c #ifdef` will be excluded by the preprocessor.

__What is the preprocessor?__  
The preprocessor is a macro processor and is run as the first step of the compilation process. The preprocessor is used by the compiler to transform your program before actual compilation. Macros are the lines on top of a C file starting with a hash. They are abbreviations of larger code constructs. The preprocessor replaces these lines with the constructs they represent before your code is handed off to the compiler. Macros can be used for several purposes.  
One of its uses is header file inclusion. In this case, the preprocessor will replace the macro with the declarations in the given header file, making them available to your program.  
Another use is macro expansion. This will replace the the occurrences of the macro with with arbitrary C code. For instance, you can use the preprocessor to define constants, even though C has its own mechanism for that.

```C
#define PI 3.1415926535
```

Macros can be used to define "functions". I've put quotes around functions, because they aren't real functions. Suppose I have

```c
#define MAX(a, b) ((a > b) ? a : b)

int max(int a, int b) {
	return (a > b) ? a : b;
}

int test_max(int a, int b, int clamp) {
	return max(clamped, a - b);
}

int test_MAX(int a, int b, int clamp) {
	return MAX(clamped, a - b);
}
```

Glancing over this code, you probably think the functions `c test_max` and `c test_MAX` are the same, right? Well, you're wrong.  
After the preprocessor finishes, `c test_max` remains unchanged. On the other hand, `c test_MAX` is changed to:

```c
int test_MAX(int a, int b, int clamp) {
	return (clamped > (a - b)) ? clamped : (a - b);
}
```

In this function, the formula `c (a - b)` is evaluated twice. No real problem, of course, but suppose we wanted to call `c MAX(a, c++)`. If `c (c > a)`, `c c++` is evaluated twice, which is obviously not what we want! Or suppose we call `c MAX(aVeryComplexFunction(a), c)`, in which case it could be that `c aVerComplexFunction` is called twice, which will spend double the CPU time.

There is also a macro for conditional compiling. This can be useful if you want, for instance, a release build with logging disabled or you need different libraries depending on the operating system.

```c
#ifdef __unix__
# include <unistd.h>
#elif defined _WIN32
# include <windows.h>
#endif
```

In this example, either `c __unix__` or `c _WIN32` is defined and you can use them to determine which operating system you are working on.

__But if the preprocessor is the first step only, what are the other compilation steps then?__  
C compilation is a multi-step process. Source code for C programs is ASCII text. These text files have to be compiled and linked in order to produce an executable file. The compilation process thus involves three steps: preprocessing, compiling and linking.  
The preprocessor makes sure that the source files are ready for compilation by doing macro expansion.  
The compiler then takes over and compiles the source code files into object files. Object files are mostly machine code (your program) but also contain information for the linker (like return addresses), which is the next phase of the compilation process.  
The linker takes all object files needed for the program, including library object files, and merges them into a single executable program.  
If desired, additional optimisations can be made on the produced executable file.

__Java has packages. Can you do something similar in C?__  
In C, there is no such thing as packages, but programmers normally organise their code in a similar way using directories. Even in Java a package is mapped directly onto a directory in the file hierarchy.  
C's modularity is actually very similar to that of Java. In Java, however, you break down your program in classes. In C, you also break down the program in smaller, more manageable parts but they do not need to be like classes. You can then use the preprocessor to include these parts in your program. The `c #include` keyword is used for this as we already discussed.

__Libraries?__  
Yes, just like Java, C comes with a predefined set of libraries. The linker looks for these libraries in predefined directories. On most UNIX-like systems, the header files are located in `c $INCLUDE_PATH:/usr/local/include:/usr/include`. The library files are located in `c $LD_LIBRARY_PATH:/usr/local/lib:/usr/lib:/lib`.
You can add other directories to these paths by setting either the `c INCLUDE_PATH` or `c LD_LIBRARY_PATH`, depending on what you want to add. Another way to do this is by giving certain directives to the compiler. For the `c gcc` compiler,  you can add directories containing header files with the `c -I` directive, and directories filled with libraries with the `c -L` directive.

You look baffled, and I understand why. You're used to `c .jar` libraries, where both the interface and the implementation are stored in one container. If your program needs a library, you just include the jar with the distribution of your program.
This approach has its flaws, of course. If all of your programs require the same jar-file, you'll have plenty of copies on your computer. If a new version of that library is released, all of these programs need to update their version.
This is what we call "static linking". This is possible in C, but "dynamic linking" is more popular, for obvious reasons. When a library is dynamically linked, the linker looks for the library at run time, before the library is needed for the first time. The libraries are stored in the directories mentioned above. If any of the required libraries doesn't exist, the linker throws an error and in most cases the program simply exits.
By using dynamically linked libraries, the user is required to install the right libraries first. This problem is solved in most UNIX/*NIX systems, where the package manager just lists these libraries as dependencies of the program, but when programs are distributed via a website, this can still be a problem.
The advantages are overwhelming. Every program on the computer always uses the same version of the library, and the library is only stored once on the system. If the library is updated, every program gets the update immediately.

__To start running a program in C, you also have to write a main method like in Java: `java public static void main(String[] args){}` ?__  
C programs are run indeed using a main method that is similar to that of Java that you mentioned but there are some subtle differences. First of all as we already discussed there are no Strings in C and the size of an array is unknown, so the main method in C has an int and a pointer to a char pointer as arguments, its header looks like this:

```c
int main(void);
```

or

```c
int main();
```

or

```c
int main(int argc, char** argv);
```

When the main method without any arguments or with `c void` is used, it is still possible to add options to the run of the program but they will have no effect whatsoever on the program. The other header has the number of arguments and the arguments themselves as parameters. When a program that is called `c test.out` and is run using 

```console
Mr.B:/tmp$ ./test.out option1 option2 
```

the parameters look like this:

```c
argc = 3
argv = {"./test.out", "option1", "option2"}
```

This means that the name of the program itself is also taken into account as an argument.
The second main difference is that the main method in C returns an int, while in Java the main method returns nothing (void return type).

__Yes I noticed that in the main header, what would you want to know when a program is terminated?__  
The `c int` that is returned shows how the program terminated, successful or unsuccessful. When the program terminated successful the return value should be `c 0`, otherwise the value should be non-zero. To help programmers not to use an incorrect value `c stdlib.h` provides two global variables called `c EXIT_SUCCESS` and `c EXIT_FAILURE`. These variables can be used perfectly as return value of the main method.

__You mentioned global variables at the end. In Java I define variables that are needed throughout the entire program by creating a Constants class that contains all these variables as public static final variables, as there are no classes in C, you can just define variables outside any function to define them as global variables?__  
That is absolutely correct, you can define variables right away in source or header files to define global variables. The global variable will be known from the declaration point until the end of the source file. If it is declared in a header file, it can be used in other files too by including the header file.
When you want to use variables in file1 that are declared in file2, the `c extern` keyword can be used to declare the variables from file2 in file1.

file1:

```c
extern int variable;

int main(){
	printf("%d \n", variable);
}
```

file2:

```c
int variable = 5;
```

When these files are compiled and run, it will print 5, as desired.

__I was wondering about inheritance, does C have something similar to inheritance as there are no classes and only structs?__  
Well, C does not support inheritance out of the box, but what you can do, is reuse a struct inside another struct, which allows sort of to extend one struct with data from another struct:

```c
typedef struct{
	int numberOfCores;
	char *brand;
} Computer;

typedef struct{
	Computer computer;
	int batteryLife;
} Laptop;
```
	
Of course this is not real inheritance, this is just a simple technique to allow programmers to extend structs using other structs.

__Okay, but what are the advantages of programming in C? Why should I learn it?__  
There are a lot of reasons to learn C. As I already told you, C is a very old programming language. And why this may seems a disadvantage at first, it is actually a big advantage. New programming languages tend to change frequently and brutally by for example the addition or deletion of keywords. An old programming language on the other hand, is stable and static: brute changes hardly occur anymore. 

Moreover, since C is so old, there already exists a lot of source code. You can't not only learn from this source code, but also use it (libraries). And, as you know, every language contains some issues. But since C already exists for over thirty years, all these issues are well documented and tutorials for workarounds are widely available on the web. Speaking of tutorials, the amount of tutorials you can use to learn C will be gigantic.

Another advantage is based on the opinion and the fact that C is generally seen as the mother of all programming languages. Since a lot of people agree on this statement, C is the language to use when you want to express common ideas in a language where everybody is comfortable with.

Furthermore, I told and showed you that a lot of languages uses the syntax that was first implemented in C. Thus, by learning C, you actually learn the syntax, or at least big parts of the syntax, of a whole bunch of languages.

__But these are all advantages because of the age and usage of C. There has to be a deeper reason why this programming language is so popular, no?__  
Correct. In comparison with Java, C is a more low level programming language. This type of language asks a lot more from the programmer. So the programmer has to do and know more. C is a called a middle level language: it combines the best parts of high level languages and low level languages. But I guess that you are right now thinking why one would want to use a lower level language when you have a high level language at your disposal, no?

__Well, maybe…__  
That's logical, since you only know Java. But by going deeper into the machine, you have a lot more control over the execution of your code. In C, you're working with bytes and even individual bits, you use pointers and you have to manage the memory yourself.  
For instance, C offers two more structures to use the memory efficiently: union and bitfields. A union is virtually the same as a struct but the size of a union is equal to the size of its largest member. The result will be that you will be able to use only one of the types used in a union. Unions are very useful when you want a variable to be able to hold multiple types of values, though not at the same time.  
The other structure is called a bitfield. Bitfields can only be used inside a struct but they allow the programmer to pack data really tight or to modify bits in a structure that was created externally to the program. However, bitfields will probably cause you severe headaches because there is no guarantee for the order in which the fields are stored. Also, signed 1-bit bitfields can only take values `c 0` and `c -1` which certainly doesn't make it any easier.

__I really don't see why you would choose for that. Java does everything for you. Simple.__  
By going under the hood, you can manage all these things yourself. Yes, I said "can", cause I think it's a privilege to do that. You can optimise the performance of your code: make it work faster, make it only use the memory it needs at that particular moment, … Furthermore, isn't it fun to know how things exactly work? And even if you don't find it fun and exciting, it is still useful to know. This will help you lot when your Java code doesn't exactly do what you want.

__Interesting... In what type of systems is this language used then? Memory-prone systems?__  
C is mainly used for system programming. This includes, as I already briefly mentioned, the implementation of operating systems. The three operating systems that you'll probably known are all fully or partially written in C: UNIX is fully written in C, while the kernel of Windows and MacOS are both written in C. The writing of an operating system would be very hard in a high-level programming language like Java or a scripting language like JavaScript. 

Another use is the development of embedded systems. As you may or may not know, the current trend is to include a CPU in every device: TV, water boiler, you name it. These devices must communicate with the hardware and have a very little memory capacity. C is the perfect language for these systems: you can directly access and manage the hardware and memory.

Oh, and before I forget to mention it: have you played or do you play video games? If so, then the chances are fairly big that this game was written in C. 

__How come?__  
Well, how would you feel if the game lags for a second at the moment you fired a bullet? You would turn the game off, right?

__Yes! That's unacceptable. The game has to be realistic. You don't see a bullet pause for a second in real life, do you?__  
Of course not. And that's the main reason why C is used to write games in: the answer to performed action should be as fast as possible.

__Wow, it seems that I've already been in touch multiple times with C: my Mac, my smartphone, games…__
And it won't stop there, I guess. Device drivers are also are also mainly written in C. You can use the basic elements of your computer by using C. And that's exactly what these devices need.

__Every programming language has some reserved keywords, so does C. What are they? And are there any special ones?__  
C has 37 keywords, at least the version C99. For me, there aren't any special ones between them. Take a look yourself and ask me if some keyword isn't clear to you. Here they are: 

<table>
<tr><td>auto</td><td>double</td><td>int</td><td>switch</td></tr>
<tr><td>_Bool</td><td>else</td><td>long</td><td>typedef</td></tr>
<tr><td>break</td><td>enum</td><td>register</td><td>union</td></tr>
<tr><td>case</td><td>extern</td><td>restrict</td><td>unsigned</td></tr>
<tr><td>char</td><td>float</td><td>return</td><td>void</td></tr>
<tr><td>_Complex</td><td>for</td><td>short</td><td>volatile</td></tr>
<tr><td>const</td><td>goto</td><td>signed</td><td>while</td></tr>
<tr><td>continue</td><td>if</td><td>sizeof</td><td></td></tr>
<tr><td>default</td><td>_Imaginary</td><td>static</td><td></td></tr>
<tr><td>do</td><td>inline</td><td>struct</td><td></td></tr>
</table>

__I know most of these keywords. That is probably because the syntax of Java is largely inherited from C's. But the goto keyword is new to me. What is it used for?__  
Ah yes, this is indeed a difference between Java and C. A so-called goto call is a one-way transfer of control to a particular part in the program code. A function call, in contrary, will normally return the control. Usually, the location whereto the code should jump is identified by a label. Here is an example of such a goto call: 

```c
goto label;
// code
label:
	// more code
```
There is (/has been) a lot of discussion about the usage of the goto statement. There exists even a programming paradigm, namely the Structured Programming Paradigm, that encourages programmers to use subroutines, block structures and for- and while-loops so that their produced code is more clear and has better quality. It states that the usage of the goto statement leads to spaghetti code that is difficult to read and to maintain since the program would largely exists of if-else test and goto jumps. [5]

And it goes even further in the Structured Programming Theorem, proved by Böhm and Jacopini. This theorem states that every algorithm can be executed by only making use of three control structures, namely sequence, selection (the if-else test) and iteration (loops). There is thus no need for the goto statement. [6]

Note by the way that "goto" is also a reserved keyword in Java. It is just made unusable. You can emulate a "`c goto`" using a scope and a "`java break`" statement.

```java
mylabel: {
	// code
	break mylabel;
}
// the location where the goto label would've been placed
// more code
```

__So can I use the `c goto` statement or not?__  
You could, but whether you should is something else entirely.

__Oh, okay. What does the register keyword do?__  
The keyword register is used to store local variables in the register of the computer. The standard location to store variables is the RAM. You should only use this for variables that need to be accessed extremely quickly. This is immediately the main advantage of storing variables in the register. The disadvantage is that size of the variable is limited to the size of the register (usually 32 bits).

It is also important to know that by using the register keyword it isn't guaranteed that this variable will be stored in register. It only says that this variable might(!) be stored in a register.

__The `c const` keyword, is it used to define a constant variable like `java final` does in Java?__  
`c const` is indeed very similar to the `java final` keyword in Java. 

```C
struct Address {
	char *streetName;
	int number, postalCode;
	char *city, *state, *country;
};
```

Java:

```Java
final Address cw = new Address("Celestijnenlaan", 200, 3001, "Heverlee", "Vlaams-brabant", "Belgium");
```

C:

```C
const Address cw = {"Celestijnenlaan", 200, 3001, "Heverlee", "Vlaams-brabant", "Belgium"};
```

The main difference is that when you define an Object as `java final` in Java, you can still change internal data of this object, while a `c const` variable cannot be changed anymore, not even the internal data.

__I see `c enum` is also a keyword of C, C also has enums that work in the same way as the enums of Java?__  
Yes enums are also available in C and look very much like structs, here is an example:

```C
enum
{
    	black = 0,  
    	blue,  
    	red,
	yellow,
	green,
	white
} color;
```

`c Black` is the default value of this enum and internally, the value of an enum is also stored as an integer as in Java.
Note that this definition requires variables of type `c enum color`. To simply define variables of type `c color`, the definition of the enum looks like this:

```C
typedef enum {
 	// body
} color;
```

__And now for something completely different. I've got this function that requires a callback as argument. In Java, I'd create an interface with one function and give an instance of that interface. How do you do this in C, where you have no objects, no real inheritance and no interfaces?__  
Easy! You give a function pointer.  
__A function pointer?__  
Yet another fun characteristic of C! Not only can you point to data structures, you can also point to functions! For example:

```C
void (*function_pointer)(int *data);
```

defines a variable `c function_pointer` that can point to a function with declaration

```C
void some_function(int * data)
```

You can now use the function pointer to call a function. You have to set the address of the function first though. Let's say you have a collection of data you want to sort using the `c bubblesort` function.

```C
int numbers[] = {5, 1, 4, 2, 3}
function_pointer = &bubblesort;
(*function_pointer)(numbers);
```

Using function pointers can be particularly useful when you want to swap algorithm implementations at runtime or you want to provide a callback to another method. 

The notation above is one way to write this, a more readable way is:

```C
typedef void (*SortFunction)(int[]);
void sort(int array[], SortFunction sortfun) { … }
// instead of
void sort(int array[], void (*sortfun)(int[])) { …}
```

__Well, this should get met going for a while. If I have more questions, I'll get back to you.__

## Some time later

__Hey, I've got a problem with a program I've written, can you take a look?__  
Sure, my CMake file is broken, so I can't do anything work-related before my colleague fixes it.  
__CMake?__  
Never mind, what's your problem?

__<after looking at the code>__

I see your problem. You are trying to call a function with two parameters, both of the parameters are results of functions that update one and the same other variable.  
In C, the order in which the parameters of a function are evaluated differs from Java. Java evaluates from left to right, while in C the order is undefined!  
Let me give an example:  
In Java:

```java
public class Value {
	public static void main(String[] args) {
		int i = 1;
		System.out.println(String.format("%d %d %d", i++, i++, i));

		i = 1;
		System.out.println(String.format("%d %d %d", i++, i++, i++));
	}
}
```

In C:

```C
#include <stdio.h>

int main() {
	int i=1;
	printf("%d %d %d\n", i++, i++, i);

	i = 1;
	printf("%d %d %d\n", i++, i++, i++);
	return 0;
}
```

You probably expect both programs to print the exact same output? Well, you're wrong.
The output is:

* Java:

```console
Mr.B:/tmp/evaluation$ javac Value.java; java Value
1 2 3
1 2 3
```

* C, compiled and run on two x64 OS X 10.8.2 systems, using both the Apple provided `c gcc` and a custom built `c gcc`; compiled and run on a x64 Ubuntu 12.04 system using `c gcc`:

```console
Mr.B:/tmp/evaluation$ gcc -o value value.c; ./value
2 1 3
3 2 1
```
* C, compiled and run on the same x64 OS X systems as above, but compiled using `c clang`:

```console
Mr.B:/tmp/evaluation$ clang -o value_clang value.c; ./value_clang
1 2 3
1 2 3
```

<b>So the output of the program depends on which compiler you use, and can even be different on the same system?  
Is C portable then? I want my code to be used on multiple platforms!</b>  

No worries, C can be portable. It isn't as simple as in Java, where you distribute one jar and it works on every system (unless you do some very dirty hacking) and on every full implementation of Java.

You can port C code, but you cannot port compiled programs. The compilers compile the C code to actual machine code. This implies that the resulting executable will only work on computers with the exact same environment (OS, ABI ([7]) …).  
The Java compiler doesn't compile to an executable. It creates Java bytecode instead, which is then run by the Java program on the user's computer.

If you want code to be completely portable, you have to take some things in account:

* You cannot use certain operations on numbers. Some systems are big endian, some are little endian. Java makes abstraction of this, but C doesn't.
* The sizes of certain types may vary, depending on which compiler is used and whether the OS is x86, x64 or something different entirely.
* Some API's differ between the different systems. You can use the `c #ifdef` preprocessor directive to change which code is actually compiled, as we discussed earlier. Important API's that differ between POSIX/UNIX/*NIX and Windows/DOS are the threads and subprocesses api, any I/O apart from what's found in `c <stdio.h>`, synchronisation api … [8]
* Do not assume that all arguments of a function are evaluated in the same order! If this could prove a problem, evaluate the arguments yourself, store the result in the stack, and use these stored values in the function.



[1]: http://en.wikipedia.org/wiki/All_persons_fictitious_disclaimer
[2]: http://en.wikipedia.org/wiki/Procedural_programming
[3]: http://en.wikipedia.org/wiki/C_(programming_language)
[4]: http://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html
[5]: http://en.wikipedia.org/wiki/Structured_programming
[6]: http://en.wikipedia.org/wiki/Structured_program_theorem
[7]: http://en.wikipedia.org/wiki/Application_binary_interface
[8]: http://blogs.msdn.com/b/csliu/archive/2009/03/20/windows-unix-and-ansi-c-api-comparison.aspx
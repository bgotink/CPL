<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Assignment 1</title>
   <meta name="author" content="Bram Gotink" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/CPL/css/syntax.css" type="text/css" />
   <link rel="stylesheet" href="/CPL/css/cpl.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/CPL/css/screen.css" type="text/css" media="screen, projection" />

</head>
<body>

<div class="site">
  <div class="title">
    <a href="/CPL">Comparative Programming Languages</a>
  </div>
  
  <div id="post">
<h1 id="toc_0">Assignment 1</h1>

<p><strong>All characters in this work are fictitious. Any resemblance to real persons, living or dead, is purely coincidental <a href="http://en.wikipedia.org/wiki/All_persons_fictitious_disclaimer">1</a></strong></p>

<h2 id="toc_1">Introduction</h2>

<p><strong>Mister B.</strong><br/>
Mister B. is an experienced C-programmer at C-Coders. All the programs that are developed in this company are written in C. And Mister B. loves that. In his student years, Mister B. also came into contact with Java. However, he already knew the language C and he only learned Java because he had to. In his opinion, C is the best language and there&#39;s no need to discuss that.  </p>

<p><strong>Denis L.</strong><br/>
Denis has just graduated from the university and is eager to start with a new chapter in his life: going to work. Today is his first day at work and he&#39;s meeting with Mister B, the leader of his assigned team. At the university, Denis came in contact with just one programming language, namely Java. How he got passed the interviews without any knowledge of C remains a mystery. But that&#39;s that. Today is the day that Denis can ask everything about C to Mister B. </p>

<h2 id="toc_2">Conversation</h2>

<p><strong>Hey mister B, this may be a stupid question, but how do I create an object in C?</strong><br/>
Simple answer, you can&#39;t. C is not an object-oriented language but a procedural one.  There are, however, certain structures in this language which allow you to create object-like structures. They only contain data, no methods or other typical object-oriented members.  </p>

<p><strong>A procedural language, you say?</strong><br/>
In a procedural programming, you typically break down a programming task into a collection of variables, data structures and subroutines. In object-oriented programming on the other hand, you break it down into objects that expose behaviour (methods) and data (variables) using interfaces. In an object-oriented language like Java, an instance of a class, operates on its own data structure. In C, all data is exposed<a href="http://en.wikipedia.org/wiki/Procedural_programming">2</a>.  </p>

<p><strong>You mentioned something about object-like structures?</strong><br/>
Yeah, they&#39;re called structures and are defined using the keyword struct. Let me give an example.</p>
<div class="highlight"><pre><code class="C"><span class="k">struct</span> <span class="n">Address</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">streetName</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="n">postalCode</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">city</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">country</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>This piece of C code defines a structure containing strings and integers. You can easily create new variables of this structure type using</p>
<div class="highlight"><pre><code class="C"><span class="k">struct</span> <span class="n">Address</span> <span class="n">homeAddress</span><span class="p">;</span>
</code></pre></div>
<p>However, this requires writing <span class="highlight"><code class="C"><span class="k">struct</span> <span class="n">Address</span></code></span> every time you want to declare a new variable of that type. You can also create the same structure using:</p>
<div class="highlight"><pre><code class="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">streetName</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="n">postalCode</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">city</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">country</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Address</span><span class="p">;</span>
</code></pre></div>
<p>Creating new Address variables is now simply</p>
<div class="highlight"><pre><code class="C"><span class="n">Address</span> <span class="n">homeAddress</span><span class="p">;</span>
</code></pre></div>
<p><strong>What&#39;s with all the stars?</strong><br/>
They are called pointers. Pointers are very common and are used almost everywhere because in C, you have direct access to the memory. A pointer is a variable that holds the location of the actual value in memory. They are like memory addresses but they aren&#39;t real memory addresses because most systems do memory translation.</p>

<p>When you declare a pointer, it initially points to <span class="highlight"><code class="C"><span class="nb">NULL</span></code></span> (memory address <span class="highlight"><code class="C"><span class="mi">0</span></code></span>). You still have to make the pointer point to the actual data that you may still need to create. In order to do this, you can use the &#39;address-of&#39; operator, &#39;<span class="highlight"><code class="C"><span class="o">&amp;</span></code></span>&#39; or allocate memory on the heap. </p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="o">*</span><span class="n">pointer_to_number</span><span class="p">;</span>
<span class="n">number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">pointer_to_number</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">number</span><span class="p">;</span>
</code></pre></div>
<p>In this example, <span class="highlight"><code class="C"><span class="n">pointer_to_number</span></code></span> is of type &#39;pointer to int&#39; and its value is the memory location of the integer <span class="highlight"><code class="C"><span class="n">number</span></code></span>. You can also access the value of <span class="highlight"><code class="C"><span class="n">number</span></code></span> through the pointer with the dereference operator, &#39;<span class="highlight"><code class="C"><span class="o">*</span></code></span>&#39;.</p>
<div class="highlight"><pre><code class="C"><span class="o">*</span><span class="n">pointer_to_int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div>
<p>Here, the value of <span class="highlight"><code class="C"><span class="n">number</span></code></span> is changed to 3 using the pointer.</p>

<p><strong>How can I access the fields of structures?</strong><br/>
The fields of a structure can be accessed using the &#39;dot&#39; operator, much like in Java:</p>
<div class="highlight"><pre><code class="C"><span class="k">struct</span> <span class="n">Address</span> <span class="n">homeAddress</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">homeNumber</span> <span class="o">=</span> <span class="n">homeAddress</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
</code></pre></div>
<p>If you have a pointer pointing to a struct, you can also access the members with the &#39;pointing-to&#39; operator, &#39;<span class="highlight"><code class="C"><span class="o">-&gt;</span></code></span>&#39;.</p>
<div class="highlight"><pre><code class="C"><span class="k">struct</span> <span class="n">Address</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">homeAddress</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">homeNumber</span> <span class="o">=</span> <span class="n">address</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
</code></pre></div>
<p>As all data of a struct is public, the fields are accessed directly.</p>

<p><strong>You said Address contains strings but if I understand correctly, there are only pointers to characters?</strong><br/>
There is no &quot;String&quot; type in C. In C, a string is an array of characters, terminated with a &#39;null&#39; character, <span class="highlight"><code class="C"><span class="sc">&#39;\0&#39;</span></code></span>. This means that a character array of length 7 can only contain a string with 6 characters as the null character takes up 1 place.</p>

<p><strong>Why is an array of characters terminated with <span class="highlight"><code class="C"><span class="sc">&#39;\0&#39;</span></code></span> ?</strong><br/>
As C never does automatic bounds checks, it means the end of an array is unknown. To know the end of the string, character arrays are terminated with <span class="highlight"><code class="C"><span class="sc">&#39;\0&#39;</span></code></span>. This termination  allows easy use of strings, because the length of the string can be determined by checking for the <span class="highlight"><code class="C"><span class="sc">&#39;\0&#39;</span></code></span> character. By the way, arrays that contain elements of a different type are not automatically null-terminated.</p>

<p><strong>As C does not perform automatic bounds checks, how does it prevent everybody from writing beyond the end of an array?</strong><br/>
Well simply said, it doesn&#39;t. The compiler will for example allow you to compile this piece of code that writes beyond the range of the <span class="highlight"><code class="C"><span class="n">overflowArray</span></code></span> array.</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">overflowArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">fixedArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">fixedArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">18</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">overflowArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fixedArray</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
</code></pre></div>
<p>This piece of code prints:</p>
<div class="highlight"><pre><code class="Text">12 
13 
14 
15 
16 
17 
6 
7 
8 
9 
</code></pre></div>
<p>I wrote integers in <span class="highlight"><code class="C"><span class="n">overflowArray</span></code></span> while I was actually writing in and beyond <span class="highlight"><code class="C"><span class="n">fixedArray</span></code></span>.<br/>
This is a very basic example of a buffer overflow. A buffer overflow occurs when     a program writes beyond the size of the buffer and thus overwrites memory that does not belong to the buffer anymore.<br/>
The buffer overflow is one of the most common bugs in software. A lot of the iOS jailbreaks use this to acquire root privileges, enabling the program to alter the OS.</p>

<p><strong>Well, it seems to me that C is very basic compared to Java, no bounds checking on arrays... I like my <span class="highlight"><code class="Java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ArrayIndexOutOfBoundsException</span></code></span>!</strong><br/>
<strong>Is C that much older than java? How was C created?</strong><br/>
The programming language C was created by Dennis Ritchie between the years 1969 and 1973. At that time, Ritchie worked at AT&amp;T Bell Labs (New Jersey, USA). This research and development company is also known for the invention of the UNIX operating system family.</p>

<p>The origin of C is by the way largely connected with this operating system family. UNIX was originally written in assembly language. When they decided to port the operating system to a PDP-11, a 16-bit minicomputer, they realised that their primary programming language at that time, namely B, couldn&#39;t take advantage of some important features of the PDP-11. This fact initiated the development of C.</p>

<p>Note that the language B is a stripped down and syntactically changed version of the programming language BCPL (Basic Compiled Programming Language). BCPL was used in an earlier operating system, namely MULTICS.</p>

<p><strong>So, did they just name this new programming language &quot;C&quot; because the previous language was named &quot;B&quot;?</strong><br/>
No, absolutely not. Well, maybe. But the main reason they called this new language C is because it actually derives a lot of features of B. As said, they needed to extend B to optimise the use of the PDP-11. It was then a logical implication to name the new language &quot;C&quot;.</p>

<p><strong>What are the additions of C in comparison with B then?</strong>
The most important addition is probably the addition of structs. To recap, structs are the object-like structures I mentioned earlier. Thanks to the implementation of these structs, C became powerful enough so that UNIX kernel could be mainly written in it. Another important addition is the addition of the data types for variables.</p>

<p>In short, you can say that C inherits the concise syntax of B and added the necessary high-level functionality and detailed features that are needed to write a (modern) operating system. The invention of C resulted in the end of B.</p>

<p><strong>We are talking about 40 years ago. As you just said, the programming language B vanished because of the invention of C. Why didn&#39;t the same happen to C? Or, in other words, why are we still talking about C these days?</strong><br/>
That&#39;s a really good question. Remember that the UNIX kernel was eventually written in C. When the UNIX operating system conquered the world, the knowledge of C became widespread and it eventually became the number one programming language. </p>

<p>Nowadays, C is still the default language for UNIX and UNIX-like systems. So if you want to make a contribution, even a small one, you&#39;ll need to know C. </p>

<p><strong>Since C code is necessary to write libraries for UNIX, I assume that the programming language is widely used?</strong><br/>
Correct. In fact, according to TIOBE Programming Community Index for November 2012, C is the most popular language on Earth with a market share of largely 19.2%. And what is interesting, is that the top 6 of this ranking is fully taken by C-based languages. This is good for a market share of 68%! In other words, more than 2 out of 3 programs are written in a language that&#39;s derived from C. That is huge. And it&#39;s the reason why C is called the mother of all programming languages.</p>

<p><strong>Wow! A 40-year old language still rocking the programming world. That&#39;s impressive! Did the language just roll off the shelve?</strong><br/>
No, of course not. There are different stages in the evolution of the language. The version of C that was used to implement the UNIX kernel is known as the &quot;Early Developments&quot;. </p>

<p>The first published version came in 1978 when Kernighan and Ritchie published their book &quot;The C Programming Language&quot;. For years, many programmers referenced this book as the informal specification of the language. Nowadays, this book is still known to C-programmers as the K&amp;R standard or the K&amp;R C.</p>

<p>In 1983, the American National Standards Institute (ANSI) filed a request for a standard specification for the C language. This standardization was largely based on the UNIX implementation and was published in 1989. This standard of C is referred to by programmers as ANSI C or C89. </p>

<p>This standard was unchanged for years. And to be more precise: for 10 years. In 1999, the standard was revised and several new features, like for example new data types (long, long int, complex) and variable length arrays, were introduced. But also the support for one-line comment to begin with // was introduced. This last feature was seen in the programming language BCPL. This standard is worldwide known as C99.</p>

<p>A last update, well at least until now, came in 2011 when the C11 standard was published. In this standard, the C standard is extended by new features like for example anonymous structures, atomic operations and multi-threading.</p>

<p><strong>Aah, interesting! Before, you said that C is the mother of all programming languages... Which languages are then derived from C?</strong><br/>
The list is enormous. But the most known languages are probably C++, C#, Objective-C, PHP, JavaScript and... Java.</p>

<p><strong>Wait, what? Java?! I don&#39;t get it…</strong><br/>
Yes, Java! The syntax of Java is largely based on C&#39;s. But don&#39;t get me wrong: there are many, many differences between C and Java. You already discovered the major difference, namely the fact that you can&#39;t create objects in C. </p>

<p>Another important difference is that C code compiles directly to machine code. Java, on the other hand, uses a virtual machine, namely the Java Virtual Machine (JVM), and all the Java code will be compiled to Java bytecode. This code runs in the JVM. The only thing that is necessary for your machine to run Java code is an installed Java Runtime Environment, or JRE, which includes a JVM. These JRE&#39;s can be freely download on the web.</p>

<p>The advantage is that when you&#39;re Java code is compiled, you can run it on every machine that has a JVM installed. It does not matter if you compiled the code on a Mac and you want to run it on a Windows machine. This is not the case with C and its C compiler since the compiler will match C code to local machine instructions. These commands could (and do) differ between machines. Thus, compiled C code cannot run on a machine that has different machine instructions.</p>

<p><strong>Oh, I see. And what is the contribution of C to the other languages that derive from it? Is it also solely the syntax?</strong><br/>
Hmm, that differs from language to language. As said, the only similarity between Java and C is the syntax. The same can be said about JavaScript and PHP. The syntax that we&#39;re talking about is the structured programming syntax, like the if-statements and for- and while-loops. Well, actually, all the languages that I mentioned before inherit this syntax. </p>

<p>Languages like C++ and Objective-C are far more closely related to C than Java is. They were invented when object-oriented languages became more widely used and extend the C-language with object-oriented capabilities. </p>

<p><strong>Wow, seems like we got a little sidetracked… Enough about C and its history. I thought you mentioned something about memory? How does that work in C?</strong><br/>
A program can allocate memory in two regions: the stack or the heap. The stack has a fixed size, which is why you can can end up with a stack overflow error. The size of the heap is not fixed and can vary during execution. 
When you instantiate variables, they are automatically stored on the stack. When the function returns, they are freed. If you need a longer lifetime for a variable, you should allocate memory on the heap. This is done with the &#39;<span class="highlight"><code class="C"><span class="n">malloc</span></code></span>&#39; function, which returns a pointer to a chunk of memory of a given size.</p>
<div class="highlight"><pre><code class="C"><span class="n">Address</span> <span class="o">*</span><span class="n">addr_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Address</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Address</span><span class="p">));</span>
<span class="n">addr_ptr</span><span class="o">-&gt;</span><span class="n">postal</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
</code></pre></div>
<p>Pointers are a powerful part of the C language. You can easily create very potent code, but you can also easily introduce bugs. One thing you mustn&#39;t forget is freeing the memory you&#39;ve allocated for the object when you no longer need it. This can be done using the &#39;<span class="highlight"><code class="C"><span class="n">free</span></code></span>&#39; function.</p>
<div class="highlight"><pre><code class="C"><span class="n">free</span><span class="p">(</span><span class="n">myAddr_ptr</span><span class="p">);</span>
</code></pre></div>
<p>If you don&#39;t do this, the memory will remain allocated, and eventually your computer will run out of memory. This is what is called a memory leak.</p>

<p>Another important fact to remember, is that the memory for your object allocated by <span class="highlight"><code class="C"><span class="n">malloc</span></code></span> is not initialised. It still contains the data that was there before <span class="highlight"><code class="C"><span class="n">malloc</span></code></span> was called. Reading variables from a freshly created <span class="highlight"><code class="C"><span class="n">Address</span><span class="o">*</span></code></span> results in undefined behaviour. Executing <span class="highlight"><code class="C"><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">myAddrPtr</span><span class="o">-&gt;</span><span class="n">streetName</span><span class="p">);</span></code></span> will probably print jibberish to <span class="highlight"><code class="C"><span class="n">stdout</span></code></span>, or even result in a memory-related error. </p>

<p><strong>Is &#39;(Address *)&#39; a cast and why do you need to cast that pointer?</strong><br/>
Yes, it is. In C, you can cast types to other types. The reason for the cast is the <span class="highlight"><code class="C"><span class="n">malloc</span></code></span> function. The declaration of <span class="highlight"><code class="C"><span class="n">malloc</span></code></span> reads</p>
<div class="highlight"><pre><code class="C"><span class="kt">void</span> <span class="o">*</span><span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div>
<p>In other words, it returns a pointer of type &#39;pointer to void&#39;. In the previous example, you declare a pointer of type &#39;pointer to Address&#39; and because of that, you technically need to cast it to that type. In fact, most compilers will do the casting automatically but doing the cast manually is generally considered good practice. For instance, C++ requires the cast and in older versions of C, <span class="highlight"><code class="C"><span class="n">malloc</span></code></span> returned <span class="highlight"><code class="C"><span class="kt">char</span> <span class="o">*</span></code></span>.</p>

<p><strong>So I can just cast a &#39;pointer to void&#39; to anything I want?</strong>
The short answer is yes. You can cast everything to something else. The compiler will give you a warning if you&#39;re casting a pointer to an integer type, and an error if you try to cast a struct variable to a primitive or vice versa.</p>
<div class="highlight"><pre><code class="C"><span class="n">Type</span> <span class="n">var</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="p">)</span> <span class="n">var</span><span class="p">;</span>
</code></pre></div>
<p>results in:</p>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp$</span> gcc cast.c
<span class="go">cast.c: In function &#39;main&#39;:</span>
<span class="go">cast.c:7:2: error: cannot convert to a pointer type</span>
</code></pre></div>
<p>In the other direction,</p>
<div class="highlight"><pre><code class="C"><span class="n">var</span> <span class="o">=</span> <span class="p">(</span><span class="n">Type</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
</code></pre></div>
<p>results in:</p>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp$</span> gcc cast.c
<span class="go">cast.c: In function &#39;main&#39;:</span>
<span class="go">cast.c:7:2: error: conversion to non-scalar type requested</span>
</code></pre></div>
<p>When using integers,</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">var</span><span class="p">;</span>
</code></pre></div>
<p>results in:</p>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp$</span> gcc cast.c
<span class="go">cast.c: In function &#39;main&#39;:</span>
<span class="go">cast.c:8:2: error: aggregate value used where an integer was expected</span>
</code></pre></div>
<p><strong>What&#39;s the difference between &#39;pointer to Address&#39; and &#39;pointer to void&#39; then?</strong><br/>
Even though pointers have equal sizes, they don&#39;t point to values of equal sizes. For instance, a variable of type <span class="highlight"><code class="C"><span class="kt">char</span></code></span> doesn&#39;t take as many memory as a variable of type <span class="highlight"><code class="C"><span class="kt">int</span></code></span>. In C, pointers are also used to iterate over a collection of data. This is done by increasing the pointer with &#39;one&#39; but that one needs to be the exact size of the structure it is pointing to. This is the reason why pointers have different types, they need to know the size of the type they are pointing to. </p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="o">*</span><span class="n">int_ptr</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">char_ptr</span><span class="p">;</span>
<span class="n">int_ptr</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// equivalent to: int_ptr += sizeof(int);</span>
<span class="n">char_ptr</span><span class="o">++</span><span class="p">;</span> <span class="c1">// equivalent to: char_ptr += sizeof(char);</span>
</code></pre></div>
<p><strong>If pointers are so powerful, why doesn&#39;t Java have them?</strong><br/>
Well, java has pointers. You just don&#39;t see them. Every instance of any subclass of <span class="highlight"><code class="Java"><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span></code></span> in Java is actually a pointer to an object. Java takes care of all the memory management, and prevents any real pointer operations (like going to the next address).</p>

<p><b>So, if I create a function</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="nf">getPostal1</span><span class="p">(</span><span class="n">Address</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">postalCode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>the argument can be invalid?</b><br/>
Yes. The argument can be NULL, or simply a pointer to something else.</p>

<p><b> Can&#39;t I create the function</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="nf">getPostal2</span><span class="p">(</span><span class="n">Address</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">.</span><span class="n">postalCode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>?</b><br/>
Of course you can! However, there is no guarantee that the <span class="highlight"><code class="C"><span class="n">address</span></code></span> parameter is a valid <span class="highlight"><code class="C"><span class="n">Address</span></code></span>. The parameter cannot be <span class="highlight"><code class="C"><span class="nb">NULL</span></code></span>, but C allows casting, so it can be everything. Another possibility would be to use <span class="highlight"><code class="C"><span class="n">getPostal3</span></code></span>.</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="nf">getPostal3</span><span class="p">(</span><span class="n">Address</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">postalCode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This returns <span class="highlight"><code class="C"><span class="mi">0</span></code></span> if <span class="highlight"><code class="C"><span class="nb">NULL</span></code></span> is given as argument.</p>

<p>By the way, there is an important difference between <span class="highlight"><code class="C"><span class="n">getPostal2</span></code></span> and <span class="highlight"><code class="C"><span class="n">getPostal1</span></code></span>/<span class="highlight"><code class="C"><span class="n">getPostal3</span></code></span>! The latter receives a pointer to the real variable, the first receives a copy of the variable!
Let me explain. Suppose we have the following two functions:</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="nf">setPostal_ptr</span><span class="p">(</span><span class="n">Address</span> <span class="o">*</span><span class="n">addr_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">postal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addr_ptr</span><span class="o">-&gt;</span><span class="n">postalCode</span> <span class="o">=</span> <span class="n">postal</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">setPostal_dir</span><span class="p">(</span><span class="n">Address</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">postal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addr</span><span class="p">.</span><span class="n">postalCode</span> <span class="o">=</span> <span class="n">postal</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>We now have the following code:</p>
<div class="highlight"><pre><code class="C"><span class="n">Address</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">;</span>
<span class="n">one</span><span class="p">.</span><span class="n">postal</span> <span class="o">=</span> <span class="n">two</span><span class="p">.</span><span class="n">postal</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span> <span class="c1">// Leuven</span>

<span class="n">setPostal_dir</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="mi">3001</span><span class="p">);</span> <span class="c1">// Heverlee</span>
<span class="n">setPostal_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">two</span><span class="p">,</span> <span class="mi">3001</span><span class="p">);</span> <span class="c1">// Heverlee as well</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">one</span><span class="p">.</span><span class="n">postalCode</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">two</span><span class="p">.</span><span class="n">postalCode</span><span class="p">);</span>
</code></pre></div>
<p>What output do you expect?<br/>
<strong>I expect to see 3001 twice, why?</strong><br/>
Well, you&#39;re wrong. The output is</p>
<div class="highlight"><pre><code class="Text">    3000
    3001
</code></pre></div>
<p>This is because the parameters of the function are always copied. So, if we call <span class="highlight"><code class="C"><span class="n">setPostal_dir</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="mi">3001</span><span class="p">);</span></code></span>
the function actually gets a copy of <span class="highlight"><code class="C"><span class="n">one</span></code></span> and a copy of <span class="highlight"><code class="C"><span class="mi">3001</span></code></span>. It then sets the <span class="highlight"><code class="C"><span class="n">postalCode</span></code></span> variable of the copy of <span class="highlight"><code class="C"><span class="n">one</span></code></span>, so <span class="highlight"><code class="C"><span class="n">one</span></code></span> itself is not changed!</p>

<p>However, when we use
<span class="highlight"><code class="C"><span class="n">setPostal_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">two</span><span class="p">,</span> <span class="mi">3001</span><span class="p">);</span></code></span>
the function gets a copy of the pointer to <span class="highlight"><code class="C"><span class="n">two</span></code></span> and a copy of <span class="highlight"><code class="C"><span class="mi">3001</span></code></span>. The copy of the pointer to <span class="highlight"><code class="C"><span class="n">two</span></code></span> obviously points to <span class="highlight"><code class="C"><span class="n">two</span></code></span> as well, so if we set the <span class="highlight"><code class="C"><span class="n">postalCode</span></code></span> like we do in the function, the actual <span class="highlight"><code class="C"><span class="n">postalCode</span></code></span> of <span class="highlight"><code class="C"><span class="n">two</span></code></span> is changed.</p>

<p><strong>But if I don&#39;t need to change the parameter, I can still use the <span class="highlight"><code class="C"><span class="n">getPostal2</span></code></span> function?</strong><br/>
That is possible. However, you have to take in account that copying the variable requires time and memory. If you have a variable of type <span class="highlight"><code class="C"><span class="n">HugeStruct</span></code></span>, this could really have an effect on the speed of your program, as it needs to copy 1MB of data every time the variable has to be copied.</p>
<div class="highlight"><pre><code class="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">];</span> <span class="c1">// a 1MB buffer</span>
<span class="p">}</span> <span class="n">HugeStruct</span><span class="p">;</span>
</code></pre></div>
<p><strong>So Java actually gives pointers to the variables in methods?</strong><br/>
Yes and no. In Java, you can change the parameter objects (e.g. <span class="highlight"><code class="Java"><span class="n">setPostalCode</span></code></span> on an <span class="highlight"><code class="Java"><span class="n">Address</span></code></span> object), but you cannot change which object the parameter references.</p>
<div class="highlight"><pre><code class="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doTest</span><span class="o">(</span><span class="n">Address</span> <span class="n">addr</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Addres</span> <span class="n">newAddr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Address</span><span class="o">(</span><span class="s">&quot;Celestijnenlaan&quot;</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="mi">3001</span><span class="o">,</span> <span class="s">&quot;Heverlee&quot;</span><span class="o">,</span> <span class="s">&quot;Belgium&quot;</span><span class="o">);</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">newAddr</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>After calling <span class="highlight"><code class="Java"><span class="n">Test</span><span class="o">.</span><span class="na">doTest</span><span class="o">(</span><span class="n">address</span><span class="o">)</span></code></span>, <span class="highlight"><code class="Java"><span class="n">address</span></code></span> is unchanged! By assigning a new object to <span class="highlight"><code class="Java"><span class="n">address</span></code></span> in the code, the reference changed to a new object in the scope of the callee (<span class="highlight"><code class="Java"><span class="n">Test</span><span class="o">.</span><span class="na">doTest</span></code></span>). In the scope of the caller however, this didn&#39;t happen.
In C, this is possible:</p>
<div class="highlight"><pre><code class="C"><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">Address</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Address</span> <span class="n">newAddr</span><span class="p">;</span>
    <span class="n">newAddr</span><span class="p">.</span><span class="n">postalCode</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
    <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">newAddr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Calling <span class="highlight"><code class="C"><span class="n">test</span><span class="p">(</span><span class="n">address</span><span class="p">)</span></code></span> results in address being reset, and the <span class="highlight"><code class="C"><span class="n">postalCode</span></code></span> is set to <span class="highlight"><code class="C"><span class="mi">3000</span></code></span>. </p>

<p><strong>I noticed you wrote if(addr) in the getPostal3 function above. Is that truly valid code? Shouldn&#39;t that be if(addr != NULL)?</strong><br/>
I understand your confusion, but this code is really valid. In Java you should write <span class="highlight"><code class="Java"><span class="k">if</span><span class="o">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span></code></span> to check whether <span class="highlight"><code class="Java"><span class="n">addr</span></code></span> is <span class="highlight"><code class="Java"><span class="kc">null</span></code></span> or not. In C you can do this by simply writing <span class="highlight"><code class="C"><span class="k">if</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span></code></span>. Thus it is possible to check no matter what type of object using <span class="highlight"><code class="C"><span class="k">if</span></code></span>, because the C language does not contain booleans. </p>

<p><strong>No booleans? How do test-statements work then?</strong><br/>
Well, C uses integers as default return value of comparison operators like &lt;, &gt; and ==.
An expression evaluates to <span class="highlight"><code class="C"><span class="n">FALSE</span></code></span> when the value is zero, otherwise the expression evaluates to <span class="highlight"><code class="C"><span class="n">TRUE</span></code></span>. 
Starting from C99, the type bool was introduced in the header file <span class="highlight"><code class="C"><span class="o">&lt;</span><span class="n">stdbool</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span></code></span>, this is actually a boolean (1 bit, true or false).</p>

<p><strong>Header files, this seems to be another difference between Java and C, what are they used for?</strong><br/>
Header files are actually a declaration of the public interfaces of the source files of libraries or self written code.</p>

<p><strong>And how do I use those in a source file then?</strong><br/>
Actually this is very similar to imports in Java. In Java, you need to import classes from other packages with the <span class="highlight"><code class="Java"><span class="kn">import</span></code></span> keyword. For example, if you want to use a class <span class="highlight"><code class="Java"><span class="n">Address</span></code></span> in the package <span class="highlight"><code class="Java"><span class="n">example</span><span class="o">.</span><span class="na">package</span></code></span>, you write:</p>
<div class="highlight"><pre><code class="Java"><span class="kn">import</span> <span class="nn">example.package.Address</span><span class="o">;</span>
</code></pre></div>
<p>In C, you need to include the header file defining the functions and structs you need. Like so:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#include &quot;Address.h&quot;</span>
</code></pre></div>
<p>The difference between these two is that Java will just use this statement to look up the Address class and its interface. C does not have classes. By including <span class="highlight"><code class="C"><span class="n">Address</span><span class="p">.</span><span class="n">h</span></code></span>, all type definitions and data declarations become available to the program. 
One more thing to notice is that the include statement can be used in two ways.</p>
<div class="highlight"><pre><code class="C"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;stdio.h&quot;</span>
</code></pre></div>
<p>Both are valid but there is a big difference. In the first line, the preprocessor will look for stdio.h in the system libraries first and if it cannot find it there, it will look for stdio.h in the current directory. Using the quotes will cause the preprocessor to only look in the current working directory, i.e. the directory where the file containing this line resides.<br/>
You can specify additional folders containing system libraries with the <span class="highlight"><code class="C"><span class="o">-</span><span class="n">I</span></code></span> option of the compiler.</p>

<p>A notable difference between C&#39;s <span class="highlight"><code class="C"><span class="cp">#include</span></code></span> and Java&#39;s <span class="highlight"><code class="Java"><span class="kn">import</span></code></span>, is that <span class="highlight"><code class="C"><span class="cp">#include</span></code></span> actually includes the entire header file in the current file. This can lead to problems when two header files <span class="highlight"><code class="C"><span class="cp">#include</span></code></span> each other.
Suppose we have two header files, <span class="highlight"><code class="C"><span class="n">a</span><span class="p">.</span><span class="n">h</span></code></span> and <span class="highlight"><code class="C"><span class="n">b</span><span class="p">.</span><span class="n">h</span></code></span>.<br/>
a.h:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#include &quot;b.h&quot;</span>
<span class="c1">// the rest of the header</span>
</code></pre></div>
<p>b.h:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#include &quot;a.h&quot;</span>
<span class="c1">// the rest of the header</span>
</code></pre></div>
<p>If I now compile the empty program <span class="highlight"><code class="C"><span class="n">headers</span><span class="p">.</span><span class="n">c</span></code></span>:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#include &quot;a.h&quot;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>the following error will show on the terminal:</p>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp/headers$</span> gcc -o headers headers.c
<span class="go">In file included from a.h:1:0,</span>
<span class="go">                 from b.h:1,</span>
<span class="go">                 from a.h:1,</span>
<span class="go">                 …</span>
<span class="go">                 from b.h:1,</span>
<span class="go">                 from a.h:1,</span>
<span class="go">                 from b.h:1,</span>
<span class="go">                 from a.h:1,</span>
<span class="go">                 from headers.c:2:</span>
<span class="go">a.h:1:15: error: #include nested too deeply</span>
</code></pre></div>
<p>This can be fixed by using the preprocessor directives <span class="highlight"><code class="C"><span class="cp">#define</span></code></span> and <span class="highlight"><code class="C"><span class="cp">#ifdef</span></code></span>.</p>

<p>a.h:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#pragma message &quot;loading a.h&quot;</span>
<span class="cp">#ifdef __A__</span>
<span class="cp">#define __A__</span>
<span class="cp">#pragma message &quot;actually loading a.h&quot;</span>
<span class="cp">#include &quot;b.h&quot;</span>
<span class="c1">// the rest of the header</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>b.h:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#pragma message &quot;loading b.h&quot;</span>
<span class="cp">#ifndef __B__</span>
<span class="cp">#define __B__</span>
<span class="cp">#pragma message &quot;actually loading b.h&quot;</span>
<span class="cp">#include &quot;a.h&quot;</span>
<span class="c1">// the rest of the header</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>The compiler will now output:</p>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp/headers$</span> gcc -o headers headers.c
<span class="go">In file included from headers.c:1:0:</span>
<span class="go">a.h:1:9: note: #pragma message: loading a.h</span>
<span class="go">a.h:5:9: note: #pragma message: actually loading a.h</span>
<span class="go">In file included from a.h:7:0,</span>
<span class="go">                 from headers.c:1:</span>
<span class="go">b.h:1:9: note: #pragma message: loading b.h</span>
<span class="go">b.h:5:9: note: #pragma message: actually loading b.h</span>
<span class="go">In file included from b.h:6:0,</span>
<span class="go">                 from a.h:7,</span>
<span class="go">                 from headers.c:1:</span>
<span class="go">a.h:1:9: note: #pragma message: loading a.h</span>
</code></pre></div>
<p>As you can see, a.h includes b.h, which includes a.h, but the second time a.h is included, <span class="highlight"><code class="C"><span class="n">__A__</span></code></span> is already defined, so the body of the <span class="highlight"><code class="C"><span class="cp">#ifdef</span></code></span> will be excluded by the preprocessor.</p>

<p><strong>What is the preprocessor?</strong><br/>
The preprocessor is a macro processor and is run as the first step of the compilation process. The preprocessor is used by the compiler to transform your program before actual compilation. Macros are the lines on top of a C file starting with a hash. They are abbreviations of larger code constructs. The preprocessor replaces these lines with the constructs they represent before your code is handed off to the compiler. Macros can be used for several purposes.<br/>
One of its uses is header file inclusion. In this case, the preprocessor will replace the macro with the declarations in the given header file, making them available to your program.<br/>
Another use is macro expansion. This will replace the the occurrences of the macro with with arbitrary C code. For instance, you can use the preprocessor to define constants, even though C has its own mechanism for that.</p>
<div class="highlight"><pre><code class="C"><span class="cp">#define PI 3.1415926535</span>
</code></pre></div>
<p>Macros can be used to define &quot;functions&quot;. I&#39;ve put quotes around functions, because they aren&#39;t real functions. Suppose I have</p>
<div class="highlight"><pre><code class="C"><span class="cp">#define MAX(a, b) ((a &gt; b) ? a : b)</span>

<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clamp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">clamped</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_MAX</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clamp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MAX</span><span class="p">(</span><span class="n">clamped</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Glancing over this code, you probably think the functions <span class="highlight"><code class="C"><span class="n">test_max</span></code></span> and <span class="highlight"><code class="C"><span class="n">test_MAX</span></code></span> are the same, right? Well, you&#39;re wrong.<br/>
After the preprocessor finishes, <span class="highlight"><code class="C"><span class="n">test_max</span></code></span> remains unchanged. On the other hand, <span class="highlight"><code class="C"><span class="n">test_MAX</span></code></span> is changed to:</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="nf">test_MAX</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clamp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">clamped</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">))</span> <span class="o">?</span> <span class="n">clamped</span> <span class="o">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>In this function, the formula <span class="highlight"><code class="C"><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span></code></span> is evaluated twice. No real problem, of course, but suppose we wanted to call <span class="highlight"><code class="C"><span class="n">MAX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span></code></span>. If <span class="highlight"><code class="C"><span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span></code></span>, <span class="highlight"><code class="C"><span class="n">c</span><span class="o">++</span></code></span> is evaluated twice, which is obviously not what we want! Or suppose we call <span class="highlight"><code class="C"><span class="n">MAX</span><span class="p">(</span><span class="n">aVeryComplexFunction</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span></code></span>, in which case it could be that <span class="highlight"><code class="C"><span class="n">aVerComplexFunction</span></code></span> is called twice, which will spend double the CPU time.</p>

<p>There is also a macro for conditional compiling. This can be useful if you want, for instance, a release build with logging disabled or you need different libraries depending on the operating system.</p>
<div class="highlight"><pre><code class="C"><span class="cp">#ifdef __unix__</span>
<span class="cp"># include &lt;unistd.h&gt;</span>
<span class="cp">#elif defined _WIN32</span>
<span class="cp"># include &lt;windows.h&gt;</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>In this example, either <span class="highlight"><code class="C"><span class="n">__unix__</span></code></span> or <span class="highlight"><code class="C"><span class="n">_WIN32</span></code></span> is defined and you can use them to determine which operating system you are working on.</p>

<p><strong>But if the preprocessor is the first step only, what are the other compilation steps then?</strong><br/>
C compilation is a multi-step process. Source code for C programs is ASCII text. These text files have to be compiled and linked in order to produce an executable file. The compilation process thus involves three steps: preprocessing, compiling and linking.<br/>
The preprocessor makes sure that the source files are ready for compilation by doing macro expansion.<br/>
The compiler then takes over and compiles the source code files into object files. Object files are mostly machine code (your program) but also contain information for the linker (like return addresses), which is the next phase of the compilation process.<br/>
The linker takes all object files needed for the program, including library object files, and merges them into a single executable program.<br/>
If desired, additional optimisations can be made on the produced executable file.</p>

<p><strong>Java has packages. Can you do something similar in C?</strong><br/>
In C, there is no such thing as packages, but programmers normally organise their code in a similar way using directories. Even in Java a package is mapped directly onto a directory in the file hierarchy.<br/>
C&#39;s modularity is actually very similar to that of Java. In Java, however, you break down your program in classes. In C, you also break down the program in smaller, more manageable parts but they do not need to be like classes. You can then use the preprocessor to include these parts in your program. The <span class="highlight"><code class="C"><span class="cp">#include</span></code></span> keyword is used for this as we already discussed.</p>

<p><strong>Libraries?</strong><br/>
Yes, just like Java, C comes with a predefined set of libraries. The linker looks for these libraries in predefined directories. On most UNIX-like systems, the header files are located in <span class="highlight"><code class="C"><span class="err">$</span><span class="n">INCLUDE_PATH</span><span class="o">:/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span><span class="o">:/</span><span class="n">usr</span><span class="o">/</span><span class="n">include</span></code></span>. The library files are located in <span class="highlight"><code class="C"><span class="err">$</span><span class="n">LD_LIBRARY_PATH</span><span class="o">:/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">:/</span><span class="n">usr</span><span class="o">/</span><span class="n">lib</span><span class="o">:/</span><span class="n">lib</span></code></span>.
You can add other directories to these paths by setting either the <span class="highlight"><code class="C"><span class="n">INCLUDE_PATH</span></code></span> or <span class="highlight"><code class="C"><span class="n">LD_LIBRARY_PATH</span></code></span>, depending on what you want to add. Another way to do this is by giving certain directives to the compiler. For the <span class="highlight"><code class="C"><span class="n">gcc</span></code></span> compiler,  you can add directories containing header files with the <span class="highlight"><code class="C"><span class="o">-</span><span class="n">I</span></code></span> directive, and directories filled with libraries with the <span class="highlight"><code class="C"><span class="o">-</span><span class="n">L</span></code></span> directive.</p>

<p>You look baffled, and I understand why. You&#39;re used to <span class="highlight"><code class="C"><span class="p">.</span><span class="n">jar</span></code></span> libraries, where both the interface and the implementation are stored in one container. If your program needs a library, you just include the jar with the distribution of your program.
This approach has its flaws, of course. If all of your programs require the same jar-file, you&#39;ll have plenty of copies on your computer. If a new version of that library is released, all of these programs need to update their version.
This is what we call &quot;static linking&quot;. This is possible in C, but &quot;dynamic linking&quot; is more popular, for obvious reasons. When a library is dynamically linked, the linker looks for the library at run time, before the library is needed for the first time. The libraries are stored in the directories mentioned above. If any of the required libraries doesn&#39;t exist, the linker throws an error and in most cases the program simply exits.
By using dynamically linked libraries, the user is required to install the right libraries first. This problem is solved in most UNIX/*NIX systems, where the package manager just lists these libraries as dependencies of the program, but when programs are distributed via a website, this can still be a problem.
The advantages are overwhelming. Every program on the computer always uses the same version of the library, and the library is only stored once on the system. If the library is updated, every program gets the update immediately.</p>

<p><strong>To start running a program in C, you also have to write a main method like in Java: <span class="highlight"><code class="Java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){}</span></code></span> ?</strong><br/>
C programs are run indeed using a main method that is similar to that of Java that you mentioned but there are some subtle differences. First of all as we already discussed there are no Strings in C and the size of an array is unknown, so the main method in C has an int and a pointer to a char pointer as arguments, its header looks like this:</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div>
<p>or</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">main</span><span class="p">();</span>
</code></pre></div>
<p>or</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
</code></pre></div>
<p>When the main method without any arguments or with <span class="highlight"><code class="C"><span class="kt">void</span></code></span> is used, it is still possible to add options to the run of the program but they will have no effect whatsoever on the program. The other header has the number of arguments and the arguments themselves as parameters. When a program that is called <span class="highlight"><code class="C"><span class="n">test</span><span class="p">.</span><span class="n">out</span></code></span> and is run using </p>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp$</span> ./test.out option1 option2 
</code></pre></div>
<p>the parameters look like this:</p>
<div class="highlight"><pre><code class="C"><span class="n">argc</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">argv</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;./test.out&quot;</span><span class="p">,</span> <span class="s">&quot;option1&quot;</span><span class="p">,</span> <span class="s">&quot;option2&quot;</span><span class="p">}</span>
</code></pre></div>
<p>This means that the name of the program itself is also taken into account as an argument.
The second main difference is that the main method in C returns an int, while in Java the main method returns nothing (void return type).</p>

<p><strong>Yes I noticed that in the main header, what would you want to know when a program is terminated?</strong><br/>
The <span class="highlight"><code class="C"><span class="kt">int</span></code></span> that is returned shows how the program terminated, successful or unsuccessful. When the program terminated successful the return value should be <span class="highlight"><code class="C"><span class="mi">0</span></code></span>, otherwise the value should be non-zero. To help programmers not to use an incorrect value <span class="highlight"><code class="C"><span class="n">stdlib</span><span class="p">.</span><span class="n">h</span></code></span> provides two global variables called <span class="highlight"><code class="C"><span class="n">EXIT_SUCCESS</span></code></span> and <span class="highlight"><code class="C"><span class="n">EXIT_FAILURE</span></code></span>. These variables can be used perfectly as return value of the main method.</p>

<p><strong>You mentioned global variables at the end. In Java I define variables that are needed throughout the entire program by creating a Constants class that contains all these variables as public static final variables, as there are no classes in C, you can just define variables outside any function to define them as global variables?</strong><br/>
That is absolutely correct, you can define variables right away in source or header files to define global variables. The global variable will be known from the declaration point until the end of the source file. If it is declared in a header file, it can be used in other files too by including the header file.
When you want to use variables in file1 that are declared in file2, the <span class="highlight"><code class="C"><span class="k">extern</span></code></span> keyword can be used to declare the variables from file2 in file1.</p>

<p>file1:</p>
<div class="highlight"><pre><code class="C"><span class="k">extern</span> <span class="kt">int</span> <span class="n">variable</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>file2:</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">variable</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div>
<p>When these files are compiled and run, it will print 5, as desired.</p>

<p><strong>I was wondering about inheritance, does C have something similar to inheritance as there are no classes and only structs?</strong><br/>
Well, C does not support inheritance out of the box, but what you can do, is reuse a struct inside another struct, which allows sort of to extend one struct with data from another struct:</p>
<div class="highlight"><pre><code class="C"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">numberOfCores</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">brand</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Computer</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">Computer</span> <span class="n">computer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">batteryLife</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Laptop</span><span class="p">;</span>
</code></pre></div>
<p>Of course this is not real inheritance, this is just a simple technique to allow programmers to extend structs using other structs.</p>

<p><strong>Okay, but what are the advantages of programming in C? Why should I learn it?</strong><br/>
There are a lot of reasons to learn C. As I already told you, C is a very old programming language. And why this may seems a disadvantage at first, it is actually a big advantage. New programming languages tend to change frequently and brutally by for example the addition or deletion of keywords. An old programming language on the other hand, is stable and static: brute changes hardly occur anymore. </p>

<p>Moreover, since C is so old, there already exists a lot of source code. You can&#39;t not only learn from this source code, but also use it (libraries). And, as you know, every language contains some issues. But since C already exists for over thirty years, all these issues are well documented and tutorials for workarounds are widely available on the web. Speaking of tutorials, the amount of tutorials you can use to learn C will be gigantic.</p>

<p>Another advantage is based on the opinion and the fact that C is generally seen as the mother of all programming languages. Since a lot of people agree on this statement, C is the language to use when you want to express common ideas in a language where everybody is comfortable with.</p>

<p>Furthermore, I told and showed you that a lot of languages uses the syntax that was first implemented in C. Thus, by learning C, you actually learn the syntax, or at least big parts of the syntax, of a whole bunch of languages.</p>

<p><strong>But these are all advantages because of the age and usage of C. There has to be a deeper reason why this programming language is so popular, no?</strong><br/>
Correct. In comparison with Java, C is a more low level programming language. This type of language asks a lot more from the programmer. So the programmer has to do and know more. C is a called a middle level language: it combines the best parts of high level languages and low level languages. But I guess that you are right now thinking why one would want to use a lower level language when you have a high level language at your disposal, no?</p>

<p><strong>Well, maybe…</strong><br/>
That&#39;s logical, since you only know Java. But by going deeper into the machine, you have a lot more control over the execution of your code. In C, you&#39;re working with bytes and even individual bits, you use pointers and you have to manage the memory yourself.<br/>
For instance, C offers two more structures to use the memory efficiently: union and bitfields. A union is virtually the same as a struct but the size of a union is equal to the size of its largest member. The result will be that you will be able to use only one of the types used in a union. Unions are very useful when you want a variable to be able to hold multiple types of values, though not at the same time.<br/>
The other structure is called a bitfield. Bitfields can only be used inside a struct but they allow the programmer to pack data really tight or to modify bits in a structure that was created externally to the program. However, bitfields will probably cause you severe headaches because there is no guarantee for the order in which the fields are stored. Also, signed 1-bit bitfields can only take values <span class="highlight"><code class="C"><span class="mi">0</span></code></span> and <span class="highlight"><code class="C"><span class="o">-</span><span class="mi">1</span></code></span> which certainly doesn&#39;t make it any easier.</p>

<p><strong>I really don&#39;t see why you would choose for that. Java does everything for you. Simple.</strong><br/>
By going under the hood, you can manage all these things yourself. Yes, I said &quot;can&quot;, cause I think it&#39;s a privilege to do that. You can optimise the performance of your code: make it work faster, make it only use the memory it needs at that particular moment, … Furthermore, isn&#39;t it fun to know how things exactly work? And even if you don&#39;t find it fun and exciting, it is still useful to know. This will help you lot when your Java code doesn&#39;t exactly do what you want.</p>

<p><strong>Interesting... In what type of systems is this language used then? Memory-prone systems?</strong><br/>
C is mainly used for system programming. This includes, as I already briefly mentioned, the implementation of operating systems. The three operating systems that you&#39;ll probably known are all fully or partially written in C: UNIX is fully written in C, while the kernel of Windows and MacOS are both written in C. The writing of an operating system would be very hard in a high-level programming language like Java or a scripting language like JavaScript. </p>

<p>Another use is the development of embedded systems. As you may or may not know, the current trend is to include a CPU in every device: TV, water boiler, you name it. These devices must communicate with the hardware and have a very little memory capacity. C is the perfect language for these systems: you can directly access and manage the hardware and memory.</p>

<p>Oh, and before I forget to mention it: have you played or do you play video games? If so, then the chances are fairly big that this game was written in C. </p>

<p><strong>How come?</strong><br/>
Well, how would you feel if the game lags for a second at the moment you fired a bullet? You would turn the game off, right?</p>

<p><strong>Yes! That&#39;s unacceptable. The game has to be realistic. You don&#39;t see a bullet pause for a second in real life, do you?</strong><br/>
Of course not. And that&#39;s the main reason why C is used to write games in: the answer to performed action should be as fast as possible.</p>

<p><strong>Wow, it seems that I&#39;ve already been in touch multiple times with C: my Mac, my smartphone, games…</strong>
And it won&#39;t stop there, I guess. Device drivers are also are also mainly written in C. You can use the basic elements of your computer by using C. And that&#39;s exactly what these devices need.</p>

<p><strong>Every programming language has some reserved keywords, so does C. What are they? And are there any special ones?</strong><br/>
C has 37 keywords, at least the version C99. For me, there aren&#39;t any special ones between them. Take a look yourself and ask me if some keyword isn&#39;t clear to you. Here they are: </p>

<table>
<tr><td>auto</td><td>double</td><td>int</td><td>switch</td></tr>
<tr><td>_Bool</td><td>else</td><td>long</td><td>typedef</td></tr>
<tr><td>break</td><td>enum</td><td>register</td><td>union</td></tr>
<tr><td>case</td><td>extern</td><td>restrict</td><td>unsigned</td></tr>
<tr><td>char</td><td>float</td><td>return</td><td>void</td></tr>
<tr><td>_Complex</td><td>for</td><td>short</td><td>volatile</td></tr>
<tr><td>const</td><td>goto</td><td>signed</td><td>while</td></tr>
<tr><td>continue</td><td>if</td><td>sizeof</td><td></td></tr>
<tr><td>default</td><td>_Imaginary</td><td>static</td><td></td></tr>
<tr><td>do</td><td>inline</td><td>struct</td><td></td></tr>
</table>

<p><strong>I know most of these keywords. That is probably because the syntax of Java is largely inherited from C&#39;s. But the goto keyword is new to me. What is it used for?</strong><br/>
Ah yes, this is indeed a difference between Java and C. A so-called goto call is a one-way transfer of control to a particular part in the program code. A function call, in contrary, will normally return the control. Usually, the location whereto the code should jump is identified by a label. Here is an example of such a goto call: </p>
<div class="highlight"><pre><code class="C"><span class="k">goto</span> <span class="n">label</span><span class="p">;</span>
<span class="c1">// code</span>
<span class="nl">label:</span>
    <span class="c1">// more code</span>
</code></pre></div>
<p>There is (/has been) a lot of discussion about the usage of the goto statement. There exists even a programming paradigm, namely the Structured Programming Paradigm, that encourages programmers to use subroutines, block structures and for- and while-loops so that their produced code is more clear and has better quality. It states that the usage of the goto statement leads to spaghetti code that is difficult to read and to maintain since the program would largely exists of if-else test and goto jumps. <a href="http://en.wikipedia.org/wiki/Structured_programming">5</a></p>

<p>And it goes even further in the Structured Programming Theorem, proved by Böhm and Jacopini. This theorem states that every algorithm can be executed by only making use of three control structures, namely sequence, selection (the if-else test) and iteration (loops). There is thus no need for the goto statement. <a href="http://en.wikipedia.org/wiki/Structured_program_theorem">6</a></p>

<p>Note by the way that &quot;goto&quot; is also a reserved keyword in Java. It is just made unusable. You can emulate a &quot;<span class="highlight"><code class="C"><span class="k">goto</span></code></span>&quot; using a scope and a &quot;<span class="highlight"><code class="Java"><span class="k">break</span></code></span>&quot; statement.</p>
<div class="highlight"><pre><code class="Java"><span class="nl">mylabel:</span> <span class="o">{</span>
    <span class="c1">// code</span>
    <span class="k">break</span> <span class="n">mylabel</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// the location where the goto label would&#39;ve been placed</span>
<span class="c1">// more code</span>
</code></pre></div>
<p><strong>So can I use the <span class="highlight"><code class="C"><span class="k">goto</span></code></span> statement or not?</strong><br/>
You could, but whether you should is something else entirely.</p>

<p><strong>Oh, okay. What does the register keyword do?</strong><br/>
The keyword register is used to store local variables in the register of the computer. The standard location to store variables is the RAM. You should only use this for variables that need to be accessed extremely quickly. This is immediately the main advantage of storing variables in the register. The disadvantage is that size of the variable is limited to the size of the register (usually 32 bits).</p>

<p>It is also important to know that by using the register keyword it isn&#39;t guaranteed that this variable will be stored in register. It only says that this variable might(!) be stored in a register.</p>

<p><strong>The <span class="highlight"><code class="C"><span class="k">const</span></code></span> keyword, is it used to define a constant variable like <span class="highlight"><code class="Java"><span class="kd">final</span></code></span> does in Java?</strong><br/>
<span class="highlight"><code class="C"><span class="k">const</span></code></span> is indeed very similar to the <span class="highlight"><code class="Java"><span class="kd">final</span></code></span> keyword in Java. </p>
<div class="highlight"><pre><code class="C"><span class="k">struct</span> <span class="n">Address</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">streetName</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="n">postalCode</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">city</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="o">*</span><span class="n">country</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Java:</p>
<div class="highlight"><pre><code class="Java"><span class="kd">final</span> <span class="n">Address</span> <span class="n">cw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Address</span><span class="o">(</span><span class="s">&quot;Celestijnenlaan&quot;</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="mi">3001</span><span class="o">,</span> <span class="s">&quot;Heverlee&quot;</span><span class="o">,</span> <span class="s">&quot;Vlaams-brabant&quot;</span><span class="o">,</span> <span class="s">&quot;Belgium&quot;</span><span class="o">);</span>
</code></pre></div>
<p>C:</p>
<div class="highlight"><pre><code class="C"><span class="k">const</span> <span class="n">Address</span> <span class="n">cw</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Celestijnenlaan&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">3001</span><span class="p">,</span> <span class="s">&quot;Heverlee&quot;</span><span class="p">,</span> <span class="s">&quot;Vlaams-brabant&quot;</span><span class="p">,</span> <span class="s">&quot;Belgium&quot;</span><span class="p">};</span>
</code></pre></div>
<p>The main difference is that when you define an Object as <span class="highlight"><code class="Java"><span class="kd">final</span></code></span> in Java, you can still change internal data of this object, while a <span class="highlight"><code class="C"><span class="k">const</span></code></span> variable cannot be changed anymore, not even the internal data.</p>

<p><strong>I see <span class="highlight"><code class="C"><span class="k">enum</span></code></span> is also a keyword of C, C also has enums that work in the same way as the enums of Java?</strong><br/>
Yes enums are also available in C and look very much like structs, here is an example:</p>
<div class="highlight"><pre><code class="C"><span class="k">enum</span>
<span class="p">{</span>
        <span class="n">black</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  
        <span class="n">blue</span><span class="p">,</span>  
        <span class="n">red</span><span class="p">,</span>
    <span class="n">yellow</span><span class="p">,</span>
    <span class="n">green</span><span class="p">,</span>
    <span class="n">white</span>
<span class="p">}</span> <span class="n">color</span><span class="p">;</span>
</code></pre></div>
<p><span class="highlight"><code class="C"><span class="n">Black</span></code></span> is the default value of this enum and internally, the value of an enum is also stored as an integer as in Java.
Note that this definition requires variables of type <span class="highlight"><code class="C"><span class="k">enum</span> <span class="n">color</span></code></span>. To simply define variables of type <span class="highlight"><code class="C"><span class="n">color</span></code></span>, the definition of the enum looks like this:</p>
<div class="highlight"><pre><code class="C"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="c1">// body</span>
<span class="p">}</span> <span class="n">color</span><span class="p">;</span>
</code></pre></div>
<p><strong>And now for something completely different. I&#39;ve got this function that requires a callback as argument. In Java, I&#39;d create an interface with one function and give an instance of that interface. How do you do this in C, where you have no objects, no real inheritance and no interfaces?</strong><br/>
Easy! You give a function pointer.<br/>
<strong>A function pointer?</strong><br/>
Yet another fun characteristic of C! Not only can you point to data structures, you can also point to functions! For example:</p>
<div class="highlight"><pre><code class="C"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function_pointer</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</code></pre></div>
<p>defines a variable <span class="highlight"><code class="C"><span class="n">function_pointer</span></code></span> that can point to a function with declaration</p>
<div class="highlight"><pre><code class="C"><span class="kt">void</span> <span class="n">some_function</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div>
<p>You can now use the function pointer to call a function. You have to set the address of the function first though. Let&#39;s say you have a collection of data you want to sort using the <span class="highlight"><code class="C"><span class="n">bubblesort</span></code></span> function.</p>
<div class="highlight"><pre><code class="C"><span class="kt">int</span> <span class="n">numbers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="n">function_pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bubblesort</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">function_pointer</span><span class="p">)(</span><span class="n">numbers</span><span class="p">);</span>
</code></pre></div>
<p>Using function pointers can be particularly useful when you want to swap algorithm implementations at runtime or you want to provide a callback to another method. </p>

<p>The notation above is one way to write this, a more readable way is:</p>
<div class="highlight"><pre><code class="C"><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">SortFunction</span><span class="p">)(</span><span class="kt">int</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="n">SortFunction</span> <span class="n">sortfun</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span>
<span class="c1">// instead of</span>
<span class="kt">void</span> <span class="nf">sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sortfun</span><span class="p">)(</span><span class="kt">int</span><span class="p">[]))</span> <span class="p">{</span> <span class="err">…</span><span class="p">}</span>
</code></pre></div>
<p><strong>Well, this should get met going for a while. If I have more questions, I&#39;ll get back to you.</strong></p>

<h2 id="toc_3">Some time later</h2>

<p><strong>Hey, I&#39;ve got a problem with a program I&#39;ve written, can you take a look?</strong><br/>
Sure, my CMake file is broken, so I can&#39;t do anything work-related before my colleague fixes it.<br/>
<strong>CMake?</strong><br/>
Never mind, what&#39;s your problem?</p>

<p><strong><after looking at the code></strong></p>

<p>I see your problem. You are trying to call a function with two parameters, both of the parameters are results of functions that update one and the same other variable.<br/>
In C, the order in which the parameters of a function are evaluated differs from Java. Java evaluates from left to right, while in C the order is undefined!<br/>
Let me give an example:<br/>
In Java:</p>
<div class="highlight"><pre><code class="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Value</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="o">,</span> <span class="n">i</span><span class="o">++,</span> <span class="n">i</span><span class="o">++,</span> <span class="n">i</span><span class="o">));</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="o">,</span> <span class="n">i</span><span class="o">++,</span> <span class="n">i</span><span class="o">++,</span> <span class="n">i</span><span class="o">++));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>In C:</p>
<div class="highlight"><pre><code class="C"><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>You probably expect both programs to print the exact same output? Well, you&#39;re wrong.
The output is:</p>

<ul>
<li>Java:</li>
</ul>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp/evaluation$</span> javac Value.java; java Value
<span class="go">1 2 3</span>
<span class="go">1 2 3</span>
</code></pre></div>
<ul>
<li>C, compiled and run on two x64 OS X 10.8.2 systems, using both the Apple provided <span class="highlight"><code class="C"><span class="n">gcc</span></code></span> and a custom built <span class="highlight"><code class="C"><span class="n">gcc</span></code></span>; compiled and run on a x64 Ubuntu 12.04 system using <span class="highlight"><code class="C"><span class="n">gcc</span></code></span>:</li>
</ul>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp/evaluation$</span> gcc -o value value.c; ./value
<span class="go">2 1 3</span>
<span class="go">3 2 1</span>
</code></pre></div>
<ul>
<li>C, compiled and run on the same x64 OS X systems as above, but compiled using <span class="highlight"><code class="C"><span class="n">clang</span></code></span>:</li>
</ul>
<div class="highlight"><pre><code class="Console"><span class="gp">Mr.B:/tmp/evaluation$</span> clang -o value_clang value.c; ./value_clang
<span class="go">1 2 3</span>
<span class="go">1 2 3</span>
</code></pre></div>
<p><b>So the output of the program depends on which compiler you use, and can even be different on the same system?<br/>
Is C portable then? I want my code to be used on multiple platforms!</b>  </p>

<p>No worries, C can be portable. It isn&#39;t as simple as in Java, where you distribute one jar and it works on every system (unless you do some very dirty hacking) and on every full implementation of Java.</p>

<p>You can port C code, but you cannot port compiled programs. The compilers compile the C code to actual machine code. This implies that the resulting executable will only work on computers with the exact same environment (OS, ABI (<a href="http://en.wikipedia.org/wiki/Application_binary_interface">7</a>) …).<br/>
The Java compiler doesn&#39;t compile to an executable. It creates Java bytecode instead, which is then run by the Java program on the user&#39;s computer.</p>

<p>If you want code to be completely portable, you have to take some things in account:</p>

<ul>
<li>You cannot use certain operations on numbers. Some systems are big endian, some are little endian. Java makes abstraction of this, but C doesn&#39;t.</li>
<li>The sizes of certain types may vary, depending on which compiler is used and whether the OS is x86, x64 or something different entirely.</li>
<li>Some API&#39;s differ between the different systems. You can use the <span class="highlight"><code class="C"><span class="cp">#ifdef</span></code></span> preprocessor directive to change which code is actually compiled, as we discussed earlier. Important API&#39;s that differ between POSIX/UNIX/*NIX and Windows/DOS are the threads and subprocesses api, any I/O apart from what&#39;s found in <span class="highlight"><code class="C"><span class="o">&lt;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span></code></span>, synchronisation api … <a href="http://blogs.msdn.com/b/csliu/archive/2009/03/20/windows-unix-and-ansi-c-api-comparison.aspx">8</a></li>
<li>Do not assume that all arguments of a function are evaluated in the same order! If this could prove a problem, evaluate the arguments yourself, store the result in the stack, and use these stored values in the function.</li>
</ul>

</div>


  
  <div class="footer">
    <a href="https://github.com/bgotink/CPL">Source</a>
  </div>
</div>

</body>
</html>
